Haskell Notes

Overview
- started in 1987 and standardized in 1999
- a purely functional language
- everything is immutable
  * can't change the value of variables
- statically typed with type inference
- lazy
  * doesn't evaluate function calls until the result is needed
- has no for or while loops
- the Vim ALE plugin has support for linting Haskell code!

Learning Resources
- free online book "Learn You a Haskell for Great Good!"
  at http://learnyouahaskell.com/
- https://www.haskell.org/
- https://wiki.haskell.org/

Installing
- browse http://hackage.haskell.org/platform/
- two options for Mac
  * download .dmg file and double-click
  * brew cask install haskell-platform

Compiler
- most popular is Glasgow Haskell Compiler (GHC)

Libraries
- browse http://hackage.haskell.org/

Interactive sessions
- enter "ghci" to start the REPL
- to exit, press ctrl-d or enter :quit
- recall previous commands with up arrow
- prompt
  * default is "Prelude> "
    - this is the name of the standard library that is automatically loaded
  * change with :set prompt "new prompt"
  * can add this command to ~/.ghci to change for all future sessions
  * mine uses an elephant emoji for the elephant on the
    cover of the book "Learn You a Haskell for Great Good!"
- to enable Vim keybindings
  * create ~/.haskeline and add "editMode: Vi"
- to get help, :help or :?
- to get information about a function, :info name
- to see the type of a name, enter :type name or :t name
  * very useful for learning
- to see the type of all expressions entered, :set +t
  * turn off with :unset +t
- to list all modules that have been imported, :show modules
- to run a shell command, :!{command}
  * ex. :!date
  * to clear the screen within ghci, :!clear
- has a builtin debugger supported by many colon commands

Source Files
- referred to as Haskell scripts
- have a file extension of .hs
- load these into an interactive session with
  :load {filename} or :l {filename}
  * can omit .hs extension when loading
- reload current script with :reload or :r
- example
  * create file hello.hs containing this function definition:
    hello name = "Hello, " ++ name + "!"
  * ghci
  * :l hello
  * hello "Mark"

Comments
- single-line: start with --
- multi-line: surround with {- -}

Operators
- these are actually infix functions
- numbers
  * basic: + - * /
  * exponentiation
    ** - Floating exponent
    ^  - Num exponent
    ^^ - Fractional exponent
    - ex. 2 ** 3 == 8
  * use parens to control order of evaluation
  * div performs integer division, discarding the remainder
    - ex. div 8 3 == 2
  * mod a b retunns a modulo b
  * gcd a b returns the greatest common denominator of a and b
    - ex. gcd 12 15 == 3
  * lcm a b returns the lowest common multiple of a and b
    - ex. lcm 6 10 == 30
  * even n determines if n is even
  * odd n determines if n is odd
  * abs n retunns absolute value of n
- logic
  && for and
  || for or
  not (the word rather than ! as in some other languages)
- comparison
  * operands must be the same type
  * == for equal
  * /= for not equal
  * < <= >= >

Boolean
- Bool - values are True and False

Numbers
- primitive types
  * Int - 4 bytes
  * Integer - arbitrary precison
  * Float - 4 bytes
  * Double - 8 bytes
  * surround negative numbers with parens
    to avoid confusion with the subtraction operator
    - ex. 5 + (-2)
- number typeclass hierarchy
  * note that a typeclass can derive from multiple other typeclasses
  * Num
    * Fractional
      * Floating
        * Float
        * Double
      * RealFrac
        * Float
        * Double
    * Real derives from Ord which adds ordering functions
      * Integral derives from Enum
        * Int
        * Integer
      * RealFrac
        * Float
        * Double
  * RealFloat derives from RealFrac and Floating
    * Float
    * Double
  * Complex
- type conversions
  * to convert an Integral to a Floating, fromIntegral integralValue

Characters
- Char - single letter surrounded by single quotes

Strings
- literal values are surrounded by double quotes
- really a list of characters
- concatenate with ++
  * really builds a new list from two lists
- the show function converts nearly anything into a String

Enumerated Types
- ex.
  -- Adding "deriving Show" allows Color values to be converted to Strings.
  -- Adding "deriving Eq" allows Color values to be compared with == and /=
  data Color = Red | Green | Blue deriving (Eq, Show)
  colorToTemp2 :: Color -> String
  colorToTemp2 color = case color of
    Red -> "hot"
    Blue -> "cold"
    _ -> "normal"

Overriding a type class implementation
- ex.
  data Size = S | M | L -- cannot say "deriving Show" since overridden below
  instance Show Size where
    show S = "small"
    show M = "medium"
    show L = "large"
  show S == "small"
  size = M
  show size == "medium"

Custom Types
- struct-like
  -- Person has name and number fields.
  data Person = Person {
    name :: String,
    id :: Int
  } deriving Show
  getName :: Person -> String
  getName (Person name _) = name
  getId :: Person -> Int
  getId (Person _ id) = id
  person :: Person
  person = Person "Mark" 19
  getName person == Mark
  getId person == 19
- union types
  data Shape =
    Circle {
      centerX :: Float,
      centerY :: Float,
      radius :: Float
    } |
    Rectangle {
      x1 :: Float,
      y1 :: Float,
      x2 :: Float,
      y2 :: Float
    }
  area :: Shape -> Float
  area (Circle _ _ radius) = pi * radius ^ 2
  area (Rectangle x1 y1 x2 y2) = (abs (x1 - x2)) * (abs (y1 - y2))
  circle = Circle 1 2 3
  rectangle = Rectangle 2 2 6 5
  area circle == 28.27
  area rectangle == 12.0

Custom Type Classes
- ex. ShapeCompare
width :: Shape -> Float
width (Circle _ _ radius) = radius * 2
width (Rectangle x1 _ x2 _) = abs (x1 - x2)
height :: Shape -> Float
height (Circle _ _ radius) = radius * 2
height (Rectangle _ y1 _ y2) = abs (y1 - y2)
class ShapeCompare kind where
  isLarger :: kind -> kind -> Bool
  isWider :: kind -> kind -> Bool
  isTaller :: kind -> kind -> Bool
instance ShapeCompare Shape where
  isLarger shape1 shape2 = area shape1 > area shape2
  isWider shape1 shape2 = width shape1 > width shape2
  isTaller shape1 shape2 = height shape1 > height shape2
-- isLarger circle rectangle == False
-- isWider circle rectangle == False
-- isTaller circle rectangle == True

$ precedence operator
- means expression after it takes precedence over expression before it
- ex. abs (x1 - x2) == abs $ x1 - x2
- I don't like this!
- another example
  putStrLn ("Hello, " ++ name)
  is the same as
  putStrLn $ "Hello, " ++ name

. precedence operator
- evaluates expression on right and passes it to function left
- need a good example

Names
- variable identifiers start with a lowercase letter
- constructor identifiers with an uppercase letter
- both can contain underscores, single quotes, letters and digits
- operators are formed from one or more of '!#$%&*+./<=>?@\^|-~'
- constructors can be operator names, if they start with a ':'
  - ex. :+ for Data.Complex

Modules
- typically define functions that are useful in other code
- module names must start with an uppercase letter
- can use functions in any module by prefixing them with the module name
  * ex. Data.List, Data.Map, System.IO
- to use functions in a module without prefixes, import ModuleName
- the most commonly used functions are defined in the Prelude module
  which is imported by default
- to define a module
  * create a file named {module-name}.hs
  * first line must be
    module {module-name} where
  * add definitions after this

Functions
- syntax to call
  * name arguments
  * arguments are separated by spaces
  * to use the result of another function as an argument
    surround the call with parens
    - ex. max (min 2 3) (min 5 4) == 4
- syntax to define
  * name parameters = expression
  * parameters are separated by spaces
  * if the name consists of letters, the function is prefix
    - if the function has two parameters,
      surround with backticks to use as infix
    - ex. 8 `div` 3 == 2
  * if the name consists of symbols, the function is infix
    - if the function has two parameters,
      surround with parens to use as prefix
    - ex. (*) 2 3 == 6
- defaults to prefix
  - can you specify that a function is infix?
- name cannot begin with an uppercase letter
- most functions are prefix functions,
  but some are infix functions
- to call a prefix function,
  start with the name followed by arguments
  all separated by spaces (no parens)
- all functions return a value
- prefix functions are evaluated before infix functions,
  so parens are needed in succ (2 * 3) which returns 7
  * succ 2 * 3 returns 9
- builtin functions
  * for numbers
    - div returns integer division result
    - max returns largest of two arguments
    - min returns smallest of two arguments
    - pred n returns n - 1
    - succ n returns n + 1
    - round (closest), ceiling (up), floor (down), truncate (toward zero)
    - sqrt n returns square root of n
    - trigonometry: sin, cos, tan, asin, acos, atan,
    - hyperbolic: sinh, cosh, tanh, asinh, acosh, atanh
    - logarithmic: log, exp (e ** n)
- builtin variables
  * for numbers
    - pi
- example
  hypot x y = sqrt (x * x + y * y)
  hypot 3 4 returns 5
- scripts can call functions defined later in the file
- can create overloaded versions
  * ex.
    place :: Int => String
    place 0 = "not started"
    place 1 = "first"
    place 2 = "second"
    place 3 = "third"
    place n = show n ++ "th"
    TODO: Handle 11, 12, 13, 21, 22, 23, ...

Function Guards
- similar to a switch statement in other languages
- ex.
  colorMeaning :: String -> String
  colorMeaning color
    | color == "red" = "fire"
    | color == "green" = "land"
    | color == "blue" = "water"
    | otherwise = "no meaning"
- a where clause computes values used in guards
  * ex.
    grade :: Int -> Int -> Char
    grade points possible
      | percent >= 90 = 'A'
      | percent >= 80 = 'B'
      | percent >= 70 = 'C'
      | percent >= 60 = 'D'
      | otherwise = 'F'
      where percent = (fromIntegral points) / (fromIntegral possible) * 100

Functions on Lists
- can use a kind of destructuring to get items from a list parameter
  * ex.
    -- This takes a list of Ints and returns a String.
    listReport :: [Int] -> String
    -- only matches empty lists
    listReport [] = "empty"
    -- only matches lists with one item
    listReport (first:[]) = "first is " ++ show first
    -- only matches lists with two items
    listReport (first:second:[]) =
      "initial are " ++ show first ++ " and " ++ show second
    -- only matches lists with more than two items
    listReport (first:rest) = show first ++ " and " ++ show rest
- can get full list and some items
  * ex.
    initial :: String -> String
    -- first is a Char; [first] is a list of Chars which is a String
    initial name@(first:rest) = name ++ " starts with " ++ [first]
- can build a new list by processing each item in a list recursively
  * ex.
    doubleList :: [Int] -> [Int]
    doubleList [] = []
    doubleList (first:rest) = first * 2 : doubleList rest
    -- Note use of cons operator (:) above.
  * can also do this with
    map (* 2) [1,2,3]

Functions that take a Function
- ex.
  double :: Int -> Int
  double x = x * 2
  -- first parameter type is a function that takes an Int and returns an Int
  process :: (Int -> Int) -> Int -> Int
  process fn n = fn (n + 1)
  -- process double 2 == 6 which is (2 + 1) * 2

Recurison
- factorial with recursion
  fac :: Int -> Int
  fac 0 = 1
  fac n = n * fac (n - 1)
  fac 4 -- 24
- factorial without recursion
  fac2 :: Int -> Int
  fac2 n = product [1..n]

Lambdas
- functions that do not have a name
- often used to pass short functions to another function
  such as map
- ex. double and add one to each item in a list
  map (\x -> x * 2 + 1) [1,2,3] = [3,5,7]

Types
- ues Hindley-Milner type system
- syntax is name :: type
- variable example
  * firstName :: String
- function example
  * add :: Num a => a -> a -> a -- syntax only works with type classes
    add x y = x + y
  * means all occurrences of a in the signature have type Num
  * takes two Num arguments and returns a Num
  * ghci detail
    - entering the type signature and definition on two lines doesn't work
    - workarounds
      * enter them on same line separated by a semicolon
        - ex. let add :: Num a => a -> a -> a; add x y = x + y
      * enter them in a block
        :{
        let add :: Num a => a -> a -> a
            add x y = x + y -- indented 4 spaces
        :}
      * turn on multline mode which automatically infers use of :{ and :}
        :set +m -- one tie
        let add :: Num a => a -> a -> a
            add x y = x + y -- indented 4 spaces
        press return to exit block
  * automatically supports currying
    - ex.
      plus5 = add 5
      plus5 2 == 7
- another function example
  * charAt :: String -> Int -> Char
    charAt str index = str !! index

Type classes
- define an interface that specific types implement
- builtin examples include Eq, Ord, Show, Read,
  Enum, Bounded, Num, Floating, and Integral

Lists
- all items must be the same type
- items are surrounded by square brackets
  and separated by commas
- ex. [1, 3, 7]
  * same as 1 : 3 : 7 : []
  * : is called the "cons" operator
- implemented as linked lists, so
  accessing items other than the first is not efficient
- to get number of items, length list
- to test whether a list is empty, null list
  * returns a boolean
- slicing
  * these raise an exception if called on an empty list
  * to get first item, head list
  * to get last item, last list
  * to get all but first item, tail list
  * to get all but last item, init list
- to create a list that contains the first n items, take n list
- to create a list that contains the last n items, drop n list
- to create list that is result of prepending new item
  * item : list
- to create list that is result of appending new item
  * list ++ [item]
- to create list where first item is modified
  * newItem : tail list
- to create a new list by concatenating two lists
  * list1 ++ list2
  * both arguments must be a list
- to get an item at a given index
  * list !! index
  * indexes start at 1
  * also used to get a character from a string since those are lists
  * slow for long lists since implemented with a linked list
- to create a reversed copy of a list: reverse list
- to get smallest number in a list: minimum list
- to get largest number in a list: maximum list
- to get sum of numbers in a list: sum list
- to get product of numbers in a list: product list
- to test whether an item is in a list: elem item list
- lists can be nested
- lists can be compared if corresponding items can be compared
  * ex. [1, 3, 5] < [2, 4, 6] gives True
  * ex. [1, 3, 5] < [1, 4, 6] gives True
  * ex. [1, 3, 5] < [1, 3, 6] gives True
  * ex. [1, 3, 5] < [1, 3, 5] gives False
- other list functions
  * notElem
  * concat takes a list of list and returns a flatten list
    - the lists cannot contain nested lists
      * recall that all items in a list must be the same type,
        so [1, [2, 3]] is not a valid list
    - ex. concat [[1,2], [3,4,5]] == [1,2,3,4,5]
  * takeWhile creates a list of all initial items
    in another list that meet a predicate
    - ex. takeWhile even [2,4,6,7,8] == [2,4,6]
  * dropWhile creates a list of all remaining items
    in another list after the initial elements meet a predicat
    - ex. dropWhile even [2,4,6,7,8] == [7,8]
  * words takes a string and returns a list of words delimited by spaces
    - ex. words "foo bar baz" == ["foo","bar","baz"]
  * unwords takes a list of works and returns a string of the words separated by spaces
    - ex. unwords ["foo","bar","baz"] == "foo bar baz"
  * splitAt creates a list of two lists obtained by
    spliting a given list at an index
    - ex. splitAt 3 [1,2,3,4,5] == [[1,2,3], [4,5]]
  * sort creates a sorted version of a list
    - must import Data.List
    - ex. sort [9, 3, 6, 2] == [2, 3, 6, 9]
  * zipWith creates a list from multiple lists using the result
    of a function called with items at corresponding positions
    - ex. zipWith min [1, 9, 5, 4] [2, 7, 6] === [1, 7, 5, 4]
    - note how the last item in the first list has no corresponding item
      in the second, so it just used that item in the result

Ranges
- create lists of all elements between two items inclusive
  * ex. [3..7] == [3,4,5,6,7]
  * ex. ['c'..'f'] == "cdef"
- can specify a step by including second item
  * ex. [5, 10..27] == [5,10,15,20,25]
- specifying a step is the only way to get a decreasing range
  * ex. [10, 9..0] == [10,9,8,7,6,5,4,3,2,1,0]
- to create an infinite list, don't specify upper bound
  * ex. [3, 6..]
  * in the REPL this will output items forever (ctrl-c to stop)
  * use a function like take to limit the output
    - ex. take 10 [3, 6..]
- replicate creates a list containing a given number of the same item
  * ex. replicate 3 "Ho" == ["Ho","Ho","Ho"]
  - note how this creates a list of strings rather than an single string
- repeat creates an infinite list of a single repeated item
  * ex. take 4 (repeat 3) === [3,3,3,3]
- cycle creates an infinite list of repeating items
  * ex. take 6 (cycle [5, 10]) === [5,10,5,10,5,10]

List Comprehensions
- like a list factory
- produces a list containing the results of an expression
  where a variable is set to each value in another list
- ex. [n * 2 | n <- [1..4]] == [2,4,6,8]
  * n * 2 is called the "output"
  * [1..4] is the list from which values are "drawn"
  * each item drawn is bound to n
- a "predicate" can be added after the draw list
  to filter the items drawn
  * ex. [n * 2 | n <- [1..4], even n] == [4,8]
  * can have any number of predicates separated by commas
- can draw values from more than one list
  * ex. [a + b | a <- [1,2,3], b <- [4,5]] == [5,6,6,7,7,8]
  * uses the cartesian product of the lists
  * goes through all items in second list for each item in first list
    - order is 1 and 4, 1 and 5, 2 and 4, 2 and 5, 3 and 4, 3 and 5
  * can split onto multiple lines, but not in the REPL
    - ex.
      [n * 2 |
       n <- [1..4],
       even n]
- ex. remove all spaces, dashes, and underscores from a string
  * squeeze str = [char | char <- str, not (elem char [' ', '-', '_'])]
  * squeeze "foo bar-baz_qux" == "foobarbazqux"

Tuples
- a fixed length set of values with specific types at each position
  * each position can hold a different type
  * called a "pair" if two items (most common size)
  * called a "triple" if three items
- items are surrounded by parens instead of
  square brackets that are used for lists
- fst t returns the first item in the two-item tuple t
  * only works for tuples with a length of 2
- snd t returns the second item in the two-item tuple t
  * only works for tuples with a length of 2
- zip creates a list of tuples from two lists
  * ex. zip [1, 2, 3] [4, 5] === [(1,4), (2, 5)]
  * number of tuples in result is equal to length of shortest list
- unzip creates a tuple of lists from a list of tuples
  * ex. unzip [(1,4), (2,5)] == ([1,2], [4,5])
- in functions that take a tuple as an argument, can destructure
  * ex. addTuples (a1, a2) (b1, b2) = (a1 + b1, a2 + b2)
    addTuples (3, 4) (7, 9) == (10, 13)

Association Lists
- a list of tuples where each tuple is a key/value pair
- there is also a Map type defined in Data.Map
- ex. mapping = [("foo", 1), ("bar", 2)]
- lookup function finds the value for a given key
  * ex. lookup "bar" mapping == Just 2
  * ex. lookup "baz" mapping == Nothing
  * just does a sequential search, so not efficient

Data.Map
- a hashmap data structure
- can create from an association list
- to use, without Data.Map prefix, import Data.Map
- ex. myMap = fromList [("foo", 1), ("bar", 2)]
- to get the value for a given key, myMap ! key
- to get the number of keys in a Map, size myMap

Conditional Logic
- if expression
  * if condition then expression else expression
  * else is required
  * no parens or semicolons
  * returns value of selected expression
- case expression
  * case variable of
      v1 -> r1
      v2 -> r2
      _ -> r3
  * ex.
    tempToColor :: String -> String
    tempToColor temp = case temp of
      "hot" -> "red"
      "cold" -> "blue"
      _ -> "green"

Higher Order Functions
- these are functions that take an argument that is a function
- map returns a list contructed from the results
  of passing each item in a list to a function
  * ex. map succ [1,3,7] == [2,4,8]
- filter
  * takes a function and list and returns a list of
    the items for which the function returns True
  * ex. filter odd [1,4,7,10] == [1,7]
  * ex. filter (> 5) [1,4,7,10] == [7, 10]
    - (> 5) creates a function using currying
- foldl is like reduce in JavaScript
  * takes a function, starting value, and a list
    - if the function is an infix function,
      surround it with parens to turn it into a prefix function
  * ex. foldl (*) 1 [1,2,3,4] == 24
    - of course this can be done more easily with product [1,2,3,4]
- foldr is like foldl, but processes
  the list items from right to left

Other Functions
- show thing
  returns the string representation of thing
  * requires thing to have a Show function
- read str :: type
  returns result of converting str to an instance of type

Variables
- to set use name = expression
- does this really create a function that
  always returns the value of the expression?

Libraries
- array
- base
- binary
- bytestring
- Cabal
- containers
- deepseq
- directory
- filepath
- ghc
- ghc-boot
- ghc-compact
- ghc-prim
- hoopl
- hpc
- integer-gmp
- process
- template-haskell
- time
- unix
- Win32

do
- creates a block
- is the value of the last expression the value of the do?

File I/O
- import System.IO
- to write from a file
  filePath = "demo.txt"
  writeDemo = do
    file <- openFile filePath WriteMode
    hPutStrLn file ("some text")
    hClose file
  writeDemo
- to read from a file
  readDemo = do
    file <- openFile filePath ReadMode
    contents <- hGetContents file
    putStr contents
    hClose file
--readDemo

Creating Executables
- create a .hs file with a "main" function
- ghc {name}.hs
- run with ./name
- example
  * in file greet.hs
    import System.IO
    main = do
      -- lines inside do must have the same indentation
      putStrLn "Enter your name."
      name <- getLine
      putStrLn ("Hello, " ++ name ++ "!")
  * ghc greet
  * ./greet

Pretty Printing
- setup
  stack install
  stack install hindent
  add ~/.local/bin to PATH
  hindent {file-path}
  * modifies file in place
  * gives "Parse error" and doesn't modify the file
    if there is a syntax error
- Vim configuration
  * browse https://github.com/alx741/vim-hindent
  * create the directory ~/.vim/ftplugin/haskell
  * save the file hindent.vim there
  * add this .vimrc
    let g:hindent_on_save = 1
  * may only work in a newly created shell

PureScript
- compiles Haskell to JavaScript
