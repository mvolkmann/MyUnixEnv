Vim Notes

Learning from scratch
- run vimtutor

Starting
- vim [filename]          - to start in a specified file
- vim +E                  - to start in file explorer
- vim .                   - same as vim +E, but not in Cygwin
- vim --remote {filename} - to edit file in existing vim session
                            (doesn't work on Mac OS X)
- vim -u NONE             - start without .vimrc
- vim --noplugin          - start without loading plugins

Help
- for help on any topic, :h[elp] {topic}
- a good place to start is :help index
- for general help, :help user-manual
- for help on version 7 features, :help version7
- if topic name isn't known, :helpgrep {guess}
  then open quickfix list with :copen
  which you mapped to <leader>q
- to navigate a link in help,
  position cursor over link and press ctrl-]
  or double-click
- to return to previous location, press ctrl-t

Configuration is specified in
- .vimrc under Unix
- _vimrc under Windows
- typically stored in home directory
  - ~ under Unix
  - C:\users\{user-name} in Windows
- to see location of current vimrc file, :echo $MYVIMRC
- it is recommended to use full command names
  rather than abbreviations in this file

---

Installing Vim
- from source
  * download source
    - hg clone https://vim.googlecode.com/hq/ vim
  * build
    - cd vim/src
    - ./configure --enable-rubyinterp --enable-pythoninterp
      * Ruby is needed by some plugins such as Command-T
      * Python is needed by some plugins such as YouCompleteMe
    - make; make install

- under Windows
  * download gvim74.exe from http://www.vim.org "Download" link
  * double-click the .exe file
  * for better Ruby support,
    - add the following to C:\Vim\_vimrc
      autocmd FileType ruby,eruby
      set omnifunc=rubycomplete#Complete
    - from a command prompt, run "gem install vim-ruby
    - download rubycomplete.vim from
      http://blog.hasno.info/blog/segfault/dev/2006/04/10/
      vim-7-ruby-omni-completion.html
      into C:\Vim\vim70d\autoload

- under Linux
  * download source from http://www.vim.org
  * bunzip2 vim-6.3.tar.bz2
  * ./configure
  * make GUI=yes
  * make install (as root)
  * to run GUI version, enter "gvim"

--- Alphabetized topics start here

Abbreviations
- typically used in insert mode
- to define, :iabbrev {abbreviation} {full-text}
  * to make buffer local, :iabbrev <buffer> {abbreviation} {full-text}
    - useful in autocmds for the FileType event
    - see example in AutoCommands section
- to use, type abbreviation in insert mode
  followed by a space (or any character not allowed in a keyword)
  which triggers expansion
  * to see list of keyword characters, :set iskeyword
  * keyword characters include letters, digits, _,
    and some special characters (192 to 255)
- examples
  * :iabbrev @@ r.mark.volkmann@gmail.com
  * :iabbrev rmv R. Mark Volkmann

ALE
- Asynchronous Linting Environment
- see ALENotes.txt

Argument List
- initially set to expanded list of files passed to vim from command-line
  * ex. vim **/*.js **/*.css
- repopulate with :args {list}
  where list is space-separated and can contain wildcards
  and ** to recurse into subdiretories
  * ex. :args **/*.js **/*.css
- to run an ex command on each file, :argdo {command}
  * can specify multiple commands separated by |
- :next or :previous to jump to next or previous file
- :last or :first/:rewind to jump to last or first file

AutoCommands
- register specified commands to be run when certain events occur
- for grouping commands in a namespace that are
  executed when specified events occur
- syntax:
  au[tocmd] [group] {events} {pattern} [nested] {cmd}
  * if multiple event names are specified, separate them by commas
- usually want these to be in a group
- examples
  * set tabstop for HTML files
    autocmd FileType html setlocal tabstop=2 (verify this from Perrin's notes)
    - could use filetype support (different file for each type) instead
  * if no file specified when Vim is started, start netrw Explore
    autocmd VimEnter * :if argc() is 0 | Explore | endif
  * if an image file is opened in Vim, open it in a web browser
    - ex. when opening from netrw Explore
    autocmd FileType image call system('git web--browse ' . shellescape(expand($.p')))
    - could use "open" instead of "git web--browse" on a Mac
  * add an abbreviation for a specific filetype
    - alternative to using SnipMate or UltiSnips
    - autocmd FileType javascript :iabbrev <buffer> iff if () {<left><left><left>
- groups
  * group related autocmds into named groups
  * if autocmds are not placed in groups, they are duplicated every time
    the file that defines them (typically .vimrc) is source
    - makes executing them slower because all the duplicates
      get executed when a command is run
  * syntax:
    augroup [name]
      autocmd! " removes all autocommands previously in this group
      [autocommands]
    augroup end
  * example: source .vimrc every time it is saved
    augroup vimrc
      autocmd!
      autocmd BufWritePost .vimrc source $MYVIMRC
    augroup end
    - see VimResized example in your .vimrc
- events
  * :help autocmd-events
  * examples
    - BufRead(Pre|Post)
    - BufWrite(Pre|Post)
    - FileRead(Pre|Post)
    - FileType - when a filetype is set for a file
    - Insert(Enter|Leave)
    - Tab(Enter|Leave)
    - VimResized
    - Win(Enter|Leave)
- warning
  * sourcing .vimrc runs autocommands again, duplicating listeners
  * this is why most autocommands should be in groups
    that start with autocmd!

Bash
- To use vi keystrokes for bash command-line editing,
  set -o vi

Buffers
  ctrl-^               - switch to previous buffer
  :bp[rev]             - switch to previous buffer (you mapped <- to this)
  :bn[ext]             - switch to next buffer (you mapped -> to this)
  ctrl-^               - toggle to previous buffer
  :ls                  - list buffers (same as :buffers)
    buffer characteristic indicators include:
    % - buffer in current window
    # - alternate buffer for ":e #" and CTRL-^
    a - active buffer: it is loaded and visible
    h - hidden buffer: loaded, but not displayed in a window
    = - readonly buffer
    + - modified buffer
    x - buffer with read errors
  :b{buffer-number} - to switch to the indicated buffer
  :b {name-fragment} - to switch to the indicated buffer
    Tab completion can be used to cycle through all the buffers
    whose file path contains the text.
    Very cool!
  :bd[{buffer-number}] - to delete the indicated buffer
    If buffer-number is omitted, currently displyed buffer is deleted.
    Multiple buffer numbers can be specified, separated by spaces.
    This really just marks the buffer as unlisted.
    To see it, use :ls!.
  :bufdo bd - to delete all buffers
  :bw[{buffer-number}] - to wipeout the indicated buffer
    Unlike :bd, this completely deletes the buffer.

BufExplorer plugin
- similar to NERD_Tree, but for buffers instead of files
- see https://github.com/vim-scripts/bufexplorer.zip
- works with MacVim
- to install using Pathogen
  * cd .vim/bundle
  * git clone https://github.com/vim-scripts/bufexplorer.zip.git
    - or add as a submodule
  * restart Vim
- using
  * \be for open in current pane
  * \bs for horizontal split open
  * \bv for vertical split open
  * use j and k keys to move up and down to highlight a buffer
  * press return to open highlighted buffer
  * press F1 for help on other command keys used in this mode

Change (delete and enter insert mode)
  c  - change selection (deletes selected text)
  cc - change line (deletes current line)
  cw - change word (deletes word under cursor)
  c$ - change from cursor to end of line
  C  - same as c$
  s  - substitute characters (can precede with # of characters)
       and enter insert mode
  c/{text}Enter - change all characters from cursor to given text

Change Case
- to change the case of the letter under the cursor, press ~
- to change the case of multiple characters,
  * to lowercase, gu{motion}
  * to uppercase, gU{motion}
  * ex. to uppercase word under cursor, gUiw
  * ex. to uppercase the next three words, 3gUw

Code Indenting
- add "filetype indent plugin on" in .vimrc to use filetype-dependent
  settings specified in files in the .vim/ftplugin directory
- settings in these files override those in your .vimrc
- for example, create .vim/ftplugin/java.vim containing
  set shiftwidth=4
  set tabstop=4
- options
  :set cindent        - for indenting source code
                        (requires "filetype indent on" in .vimrc)
  :set shiftwidth={#} - sets number of spaces used for indentation
  :set sw={#}         - same as above
  :set cinoptions=(1s - to indent continuation lines with an open paren
                        by one shiftwidth
                        (see :help cinoptions-values for more options
                         and a list of the defaults)
- commands
  ==                  - fixes indentation of current line or selected lines
  =                   - fixes indentation of selected lines
  >                   - indents selected lines
  >>                  - indents current line
  <                   - outdents selected lines
  <<                  - outdents current line
  gg=G                - goes to first line then reindents entire file

Color Schemes
- language-specific syntax highlighting definition files are in
  ~/.vim/syntax (ex. javascript.vim)
  * to reload changes to these files, can enter :source .vimrc
- can use Solarized color theme
  * but using this in iTerm changes the values of the standard colors!
  * try setting iTerm color presets to "Light Background" or "Dark Background"
    instead of a Solarized variant
- in GVim, see Syntax...Highlight Test
- add "syntax on" in .vimrc to enable colors
- :hi - to see all the current syntax colors
- to see the syntax groups that are applied to the text under the cursor
  * :echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
  * you mapped this to <leader>sg
- standard color names (case insensitive)
  * white, black, brown (looks like orange),
  * gray, red, green, yellow, blue, magenta, cyan
    (above can be preceded by "light" or "dark")
- cterm color codes
  * see vim-cterm-colors.png in this directory
- save color scheme .vim files in
    ~/.vim/colors for Unix
    $VIM_HOME/vimfiles/colors for Windows
  * also see schemes in /usr/share/vim/vim72/colors
- find valid color names in /usr/X11R6/lib/X11/rgb.txt.
- to change to a named color scheme defined in a .vim file
  stored in the appropriate colors directory,
  :colo[rscheme] {name} - use color scheme from file {name}.vim
  For example, :colo evening
- to cycle through all the installed color schemes,
  enter ":colorscheme " and then continually press Tab.
  To see all the installed color schemes,
  enter ":colo " and press ctrl-d.
- font styles
    bold, italic, underline, reverse, standout, NONE (to reset)
- font names
  * default is FixedSys
  * set with font attribute of highlight command
    - ex. hi Comment font=Courier
- examples of changing individual colors
  :hi Normal guifg=black guibg=white
  :hi comment ctermfg=blue - when using a terminal window
  :hi comment guifg=blue - when using a GUI
  :hi Search ctermfg=white ctermbg=red
  :hi LineNr ctermfg=0 - to display line numbers in gray
- can also set ctermbg and guibg
- recommendations
  hi Normal font=Fixedsys ctermfg=black ctermbg=white guifg=black guibg=white
  hi Comment ctermfg=darkgray guifg=darkgray
  hi Constant ctermfg=darkgreen guifg=darkgreen
  hi Define ctermfg=magenta guifg=magenta
  hi Fold ctermfg=0 ctermbg=1 " gray on red
  hi Identifier ctermfg=blue guifg=blue
  hi IncSearch ctermfg=white ctermbg=gray
  hi LineNr ctermfg=gray guifg=gray
  hi Search cterm=reverse ctermfg=3 ctermbg=1 \
            gui=reverse guifg=yellow guibg=red
  hi Special ctermfg=5 guifg=orange
  hi Statement ctermfg=blue guifg=blue
  hi Todo ctermfg=3 - to display TODO in comments in yellow
  hi Type ctermfg=red guifg=red

Comments in .vimrc file
- precede with " character and extends to end of line

Compiling code
- see :help quickfix.txt

Completion of commands after :
  tab - to complete a command name, file path, ...
  - to cycle through possible matches, keep pressing tab
  ctrl-d - display list of all possible matches

Completion in insert mode
  ctrl-n or down arrow - cycle to next matching word and substitute it
  ctrl-p or up arrow - cycle to previous matching word and substitute it
  - these consider all words in all open buffers
  - to select word under cursor in list,
    just continue typing (ex. space)
  - can also use up and down arrow keys to navigate list,
    but must press return key to substitute a word
  - can enable this with tab key using the following line,
    but this conflicts with the snipmate plugin, so don't do it!
    imap <TAB> <C-n>
  - to allow filtering of word list while typing,
    begin a particular form of completion (ex. ctrl-x ctrl-k),
    immediately press ctrl-p, then type
  - to cancel completion without selecting a word, ctrl-e
  - to only consider words in the current buffer, ctrl-x ctrl-n
  - for dictionary lookup, ctrl-x ctrl-k
    * you mapped <leader>d to this
    * configure location of dictionary file in .vimrc
      with set dictionary={file-path}
  - for thesaurus lookup, ctrl-x ctrl-t
    * configure location of thesaurus file in .vimrc
      with set thesaurus={file-path}
  - for filename completion of files in current working directory,
    ctrl-x ctrl-f
    * it's not necessary to type anything before invoking this
    * see "Working Directory" section for commands to see and change it
    * use ctrl-n and ctrl-p to navigate the list
    * if on a directory, press ctrl-x ctrl-f again to navigate into it
  - also see section on Omni-completion

Copy (yank)
  y  - yank (copy) selection
  yw - yank (copy) word (cursor position to end of work)
  yiw - yank (copy) inner word (under cursor)
  yy - yank (copy) current line
  Y  - same as yy

Counts
- most commands can be preceded by a number that indicates
  how many times the command should be executed

CtrlP plugin
- fuzzy search for file paths, filenames, and
  most recently used (mru) files
- similar to Command-T plugin, but faster
  and doesn't depend on Ruby support
- :h ctrlp-commands
- :h ctrlp-mappings
- you mapped ctrl-p to this
  * let g:ctrlp_map = '<c-p>'
  * let g:ctrlp_cmd = 'CtrlP .' " note dot to start in current directory
- first time ctrl-p is pressed, will index files (takes a few seconds)
- after pressing ctrl-p
  * press ctrl-f to cycle through modes (files, buffers, mru files)
  * press ctrl-d to toggle between full path and filename-only search
    - stays in selected mode until you change it
  * press ctrl-r to toggle between string and regex mode
  * type characters to match in file paths or names depending on mode
  * use ctrl-j and ctrl-k to navigate list
  * to open file under cursor
    - press enter to open in current window
    - press ctrl-v to open in new vertical split
    - press ctrl-s to open in new horizontal split
  * to close without selecting a file, press esc or ctrl-c

Delete
  d  - delete selection
  dd - delete current line
  de - delete to end word under cursor
  diw - delete word under cursor
  dw - delete to beginning of next word or
       whitespace from cursor to next non-whitespace
  d$ - delete from cursor to end of line
  D  - same as d$
  x  - delete character under cursor or visual selection
  d/{text}Enter - delete all characters from cursor to given text
  To delete without affecting the clipboard, precede command with "_
  which sends the deleted content to the "blackhole" register.
  For example, "_dd.

Diffs
  There are many ways to use this.  One way is as follows.
  - open first file
  - ":sp" to split the window
  - open second file in second window
  - ":diffthis" in both buffers
  - "]c" to move to next difference
  - "[c" to move to previous difference
  - ":set nodiff" to turn off diff in the current buffer
  - for diffs of Git versions, use Gdiff command in Fugitve plugin
    or git-gutter plugin

EasyMotion
- makes it faster to jump to a spot in a file
- for detailed help, :help easymotion.txt
- all keyboard shortcuts start with <leader><leader>
- to jump forward to a given word
  * enter <leader><leader>w
  * the first letter of the next 26 words are temporarily replaced by
    the letters a-z in red and the first two letters of the remaining
    words are replaced by other character combinations in yellow
  * press the letter or letter combination to jump to
- word commands
  * w | beginning of word forward (you changed to go in both directions)
  * W | beginning of WORD forward
  * b | beginning of word backward
  * B | beginning of WORD backward
  * e | end of word forward
  * E | end of WORD forward
  * ge | end of word backward
  * gE | end of WORD backward
- line commands
  * j | line forward
  * k | line backward
- character commands
  * s | find (search) {char} forward and backward
  * f{char} | find {char} forward
  * F{char} | find {char} backward
  * t{char} | till before {char} forward
  * T{char} | till after {char} backward

Echo
- :ec[ho] expr ...
  * starts a new line and outputs each expression with a space
    between each in the message area below the status line
  * expressions must evaluate to strings
  * strings can contain \n for newlines to output multiple lines
- :echon expr ...
  * similar to echo, but doesn’t add a space between the expressions
- :echom[sg] expr ...
  * similar to echo, but also saves output in message history
    - see "Message History" section
  * useful for debugging Vimscript
- :echoe[rr] expr ...
  * same as echomsg, but rendered as an error message

Filtering Lines
- to pass a range of lines to a shell command,
  select the lines using V, type ! and then a shell command
- selected lines will be replaced by the command output
- for example, to sort imports at the top of a Java source file,
  select them and enter "!sort"
  * requires shell sort command (not in Windows, but in Cygwin)

FixMyJs
- runs "eslint --fix" on current buffer without saving it
- you configured <leader>f to run this

Folding
- commands to control folding include
  zfap - create a new fold
  zo - open fold under cursor
  zc - close fold under cursor
  za - toggles fold under cursor (alternative to zo and zc)
  zO, zC, and zA - recursive versions of above
  zf - fold selected lines
  zj - move to next fold
  zk - move to previous fold
  zr - reduce/open all folds one level deep
  zR - recursive version of zr (all levels)
  zm - fold more; close all folds
  zM - recursive version of zm (all levels)
- to configure folding of javadoc-style comments, add this to .vimrc.
  autocmd FileType java :set fmr=/**,*/ fdm=marker fdc=1
- can use triple braces in comments to manually define fold regions
  * see your .vimrc file
- to cause files of certain types to start with all folds closed
  when a file is opened, see :help foldlevel and :help foldlevelstart
  * value is negative (not used; default), 0 (all folds closed),
    1 (some folds closed), or 99 (no folds closed)
- JavaScript folding is configured in .vim/ftplugins/javascript.vim

Fonts
- example
  :set guifont=Monaco:h14

Fugitive
- for issuing Git commands from inside Vim
- :help fugitive
- all commands start with "G"
- can run any Git command with ":Git {command}
- provides auto-completion of repository paths
- % refers to the current file
  * ex. :Git add % and :Git mv % {new-path}
- many shorthand commands for common operations
  that also interact with the current buffer
  * :Git checkout % to revert current file
    - can be performed with :Gread
  * :Git add % to stage current file
    - can be performed with :Gwrite
  * :Git mv % {new-path} to move or rename current file
    - can be performed with :Gmove {new-path}
  * :Git rm % to remove current file
    - can be performed with :Gremove
    - only stages the file to be deleted; doesn't commit
    - does not delete the buffer
  * :Git commit -av to commit modified files
    - can be performed with :Gcommit -av
      and commit comments can be entered in a split window
  * :Git blame to see who last modified each line in a file
    - can be performed with :Gblame
  * :Git status to see files that have been added or modified
    - can be performed with :Gstatus
      * use ctrl-n and ctrl-p to move to next and previous file
      * to stage or unstage file on current line, press "-"
      * to view file on current line, press enter key
  * :Git diff to see differences in current file
    and the last committed version
    - can be performed with :Gdiff
    - add a SHA to see differences with a specific revision
    - to exit, close the readonly buffer marked "RO" with :bd
      or use :only in the other buffer
    - committed version is on left and uncommitted version is on right
    - added lines are green
    - removed lines are red
    - when run on a file containing merge conflict markers
      * a three-way merge with three vertical splits is presented
      * the target file (2) is on the left
      * the merge file (3) is on the right
      * the file with conflict markers (1) is in the center
      * position cursor on a conflict in center split
      * to keep changes from target (left) enter :diffget //2 | diffup
      * to keep changes from merge (right) enter :diffget //3 | diffup
      * the diffup command in the previous two lines
        updates diff highlighting of the buffers
        and can be run separately with :diffupdate
      * to jump to next changeset, press ]c (same as in Diffs section)
      * to jump to previous changeset, press [c (same as in Diffs section)
      * when finished resolving conflicts
        - make sure cursor is in center window
        - enter ":only" to close the target and merge windows
        - :Gcommit -av
- relative paths passed to commands
  * paths that start with / are relative to the repository root directory
  * other paths are relative to the current file directory

git-gutter
- shows diff symbols in gutter while editing any file that is in a git repo
- ~ means changed, + means added, _ means deleted
- to toggle display of this gutter, :GitGutterToggle
- see https://github.com/airblade/vim-gitgutter

global
- :[range]g[lobal]/{pattern}/[cmd]
  executes cmd on all lines in [range] that match {pattern}
  * ex. :g/^$/d deletes all empty lines
  * ex. :g/^\s*$/d deletes all lines that are empty or only contain whitespace
  * if [range] is omitted, all lines in file are considered

grep (also see vimgrep)
- searches files in and below current directory (faster than vimgrep)
- uses an external shell command
  * grep by default which doesn't include column numbers in output
    so cursor can't move to the column of the match
  * can configure to use another command like ack or "The Silver Searcher"
    - see "Silver Searcher" section
- :gr[ep] [options] {pattern} {files}
  * -i option makes case-insensitive
  * pattern can be a regex surrounded by /'s
  * files can use * wildcard to match zero or more characters
  * files can use ** to recursively search subdirectories
  * populates quickfix list
    - use :lgr[ep] to populate location list instead
    - can use "unimpaired" plugin key mappings to navigate
  * ex. gr parseInt **/*.js

HTML Output
- to write a source file out as HTML,
  including color-coded syntax highlighting,
  enter :TOhtml.
  * creates a buffer with the name of the file and ".html" at the end
  * need to write it with :w

Installing Plugins
- install Pathogen
- to see list of plugins that were successfully installed,
  :scriptnames
- see "Submodules" section in GitNotes.txt
  * describes how to add Vim plugin Git repos as submodules of your Git repo
  * example
    - cd ~/MyUnixEnv
    - git submodule add https://github.com/wincent/Command-T.git .vim/bundle/command-t

Key Mapping
- to show current key mappings,
  * map - shows all mappings?
  * nmap - shows normal mode mappings
  * imap - shows insert mode mappings
  * these do not show builtin mappings
    - probably just have to use help command
      (see email from Bill Odom on 5/31/14)
- to define a key
  * "nore" variants avoid recursive mappings where
    key mappings in the command are interpreted again
    - it is recommended to use these variants
      unless recursive evaluation is explicitly needed
  * for normal mode, nmap or nnoremap
    - nnoremap {key} {command}
  * for insert mode, imap or inoremap
    - inoremap {key} {command}
    - in insert mode, <c-o> escapes to normal mode for one command
      and then switches back to insert mode
  * for visual mode, vmap or vnoremap
    - vnoremap {key} {command}
  * for normal and visual mode, map or noremap
    - nnoremap {key} {command}
  * noremap versions do not take existing mappings into account
    when running the command
    - recommended over non-noremap versions
- to show a single key definition,
  omit {command} from the commands above that define them
- special keys are specified inside angle brackets
  - "c-" stands for ctrl key
  - examples: <cr>, <esc>, <space>, <c-d>
  - can use these inside command string
- can include special unicode characters in command string
  with &#9999; where 9999 is the decimal unicode value
- "ex" commands start with :
  - ex. map <F5> :CoffeeRun
- to avoid displaying the command when the key is pressed,
  preceded the key with <silent>
  * ex. nnoremap v <silent> :vsplit<cr>
- to define a mapping that is only active buffers of a specific file type
  * define mapping in .vim/ftplugin/{file-type}.vim like this:
    nnoremap <buffer> v :vsplit<cr>
- can use both <buffer> and <silent>, but must be in that order
- in .vimrc, can't put comments at end of a mapping
- to call a function defined in script scope (with s:)
  from a key mapping
  nnoremap {key} :call <SID>{fn-name}()
  * must define mapping in the same file that defines the function
- to map <c-s> or <c-q>, disable start/stop output control
  in .bashrc with "stty -ixon"
- to undefine a key
  * for normal mode, nunmap {key}
  * for insert mode, iunmap {key}
  * for visual mode, vunmap {key}

Keyboard Macros
  q{letter} - to start recording macro {letter}
  q         - to stop recording
  @{letter} - to call macro {letter}
  @@        - to call the last executed macro again
- macros are saved across editing sessions

Leader Key
- first key pressed to invoke many plugin commands
  and typically your own custom key mappings
- defaults to \
  * to see current value, :let mapleader
  * to change to comma, add this to .vimrc
    let mapleader = ","
- local leader
  * a prefix for mappings that only take effect
    for certain types of files,
    like JavaScript or HTML files
    * often used in key mappings of filetype plugins
  * defaults to \
    - to change to backslash, add this to .vimrc
      let maplocalleader = "\\"
      or
      let maplocalleader = '\'

Location List (also see Quickfix List)
- like quickfix list, but associated with the current window
- each window can have its own
- uses same commands, but prefixed with "l" instead of "c"

Marks
- allow marking locations and quickly jumping to them
- named similarly to registers, but not related to them
- to set
  * to current line/column location, m{letter}
  * to first non-blank character in current line, :ma[rk] {letter}
  * letter can be
    - lowercase - valid within the current buffer for session
    - uppercase - valid between buffers for session
- to visit
  * specific line/location marked, `{letter}
  * first non-blank character in line containing mark, '{letter}
  * last location in last file edited, `0 or '0
    - for previous files, use numbers 1 to 9
  * to return to the previous location,
    jump to the mark named ' with ''
    - can use repeatedly to toggle the location back and forth
- to list current marks in the current buffer, :marks
- to delete marks in current buffer
  * all, :delm[arks]!
  * specific, :delm[arks] {marks}

Message History
- :mes[sages] to see content of message history
- will see "Press ENTER or type command to continue" at bottom
  * can also press space
  * press g< to see last page of previous command output
- can’t clear message history

Modes
- normal - for navigating and manipulating text
- insert - for inserting text; many ways to enter (a, i, A, I, C, s, ...)
  * keys to enter insert mode
    a - enter insert mode after cursor (append)
    A - enter insert mode at end of current line (append)
    i - enter insert mode before cursor
    I - enter insert mode at start of current line
    o - "open" new line after current one and enter insert mode
    O - "open" new line before current one and enter insert mode
- replace - for replacing characters under cursor (overstrike)
  * press R to enter replace mode
  * can also replace an individual character without entering replace mode
    by pressing r and a replacement character
- visual - for selecting text and manipulating it
  * character (v), line (V), and block (ctrl-v; rectangular selection) submodes
  * see "Select in Visual Mode" section
  * visual block mode example
    - move to block upper-left
    - press ctrl-v
    - move to block lower-right
    - press c
    - enter replacement text
    - press esc
- select - similar to visual, but Windows-like
  * not sure when this would be desirable
- command-line - for entering one ex command (:)
  * returns to normal mode after running one command or pressing esc
- ex - for entering multiple ex commands (Q)
  * like command-line mode, but doesn’t return to normal mode
    after running a single command
  * to return to normal mode, enter vi[sual]
- operator pending
  * when an operator character has been pressed and
    Vim is waiting for a motion command to be entered
- to exit current mode and return to normal mode,
  press esc or ctrl-[ (except in ex mode)

Moving Around
  gg       - beginning of file
  G        - end of file
  ctrl-f   - forward one page
  ctrl-b   - backward one page
  ctrl-d   - forward half page
  ctrl-u   - backward half page
  H        - highest (top) line in window; doesn't scroll
  L        - lowest (bottom) in window; doesn't scroll
  M        - middle line in window; doesn't scroll
  zt       - move current line to top of window (z Enter also)
  zb       - move current line to bottom of window
  zz       - move current line to center of window
  {        - backward one paragraph (to previous blank line in source code)
  }        - forward one paragraph (to next blank line in source code)
  (        - backward one sentence
  )        - forward one sentence
  0        - beginning of line
  ^        - first non-blank char in line
  $        - end of line
  e        - end of next word
  w        - forward to beginning of next word
  b        - backward to beginning of previous word
  {count}G - line number {count}
  arrows   - one char or line at a time;
             must hold shift key when in visual mode if "behave mswin"
  h        - move left one char
  l        - move right one char
  j        - move down one line
  k        - move up one line
  f{char}  - forward to next occurrence of {char} on same line
           - repeat forward with ; and backward with ,
  F{char}  - backward to previous occurrence of {char} on same line
  t{char}  - forward to just before next occurrence of {char}
  T{char}  - backward to just before previous occurrence of {char}

NERD_Tree plugin
- tried it, but like using built-in netrw better

NERD Commenter
- <leader>ci toggles commenting of current line
- <leader>cc comments lines selected in visual mode with single line comments
- <leader>cm comments lines selected in visual mode with one multiline comment
- <leader>cu uncomments lines selected in visual mode

Netrw (network-oriented reading, writing, and browsing)
  :E[xplore] [start-path]  - open explorer in current window
  :S[explore] [start-path] - open explorer in split window
  Once in explorer window,
  ?         - toggles display of help on keys to use in explorer
  Enter key - opens file/directory under cursor in explorer
  o         - opens file/directory in new window, leaving explorer displayed
  -         - goes up to parent directory
  i         - toggles display of file sizes, modification dates,
              and the layout (including tree view!)
  D         - deletes file
  R         - renames file

Numbers
- ctrl-a increments number under cursor
- ctrl-x decrements number under cursor

Omni-completion
- similar to intellisense in some IDEs
- Vim ships with support for several languages
  including HTML, CSS, JavaScript, PHP, Ruby, and SQL
- to get a list of possible completions, press ctrl-x ctrl-o
- like other kinds of completion,
  navigate the list with ctrl-n and ctrl-p
- when the desired completion is under the cursor, just continue typing
- in HTML, can use after an element name to see possible attribute
- in CSS, can use after a property name to see possible values

Opening, Saving and Quiting
  :e {name} - edit file {name}; file is created if it doesn't exist
              Can use FTP to edit remote files.  For example,
              :e ftp://www.ociweb.com/index.html
              Can use scp to edit remote files.  For example,
              :e scp://volkmanm@xi/BAE/JSFTacan/
                 branches/dev-branch/test/vector/baevector.h
              (will prompt for username/password;
               didn't seem to write changes back!)
  :e        - reload current file (useful if modified outside vim)
  :r {name} - insert content of file {name} after cursor
  :w        - write (save);
              you mapped <c-s> to do this in both normal and insert modes
              (search for -ixon in this document)
  :q        - quit current window unless changed
  :q!       - quit current window and discard changes
  :qall     - quit all windows
  :wq       - write and quit
  :x        - same as :wq, but only writes if changed
  ZZ        - same as :x

Options
- one way to view and set options is to enter ":options"
  * opens a window that displays all the options,
    provides a description of each, and shows ther current values
- boolean options
  * to enable, :set {name}
  * to disable, :set no{name}
  * to toggle, :set {name}!
  * to determine if enabled, :set {name}?
    - outputs {name} or no{name}
- value options
  * to set, :set {name}={value}
  * spaces around = are not allowed
  * to see current value, :set {name}jj?
- can set multiple options with one :set command
- to work with values specific to current buffer
  * use :setlocal instead of :set
    - these take precedence over global options
    - can't be used with all options
- popular options
  * nu[mber] - boolean; adds line numbers
    - defaults to off
    - relativenumber or rnu shows line numbers relative to line with cursor
      to help determine count for vertical motion commands
  * numberwidth or nuw - value is width of line number column
    - defaults to 4; minimum is 1; maximum is 10
  * wrap - boolean; wraps display of lines longer than window width
    - doesn't add newlines to file
    - defaults to on
  * shiftround - boolean; rounds indent to multiple of shiftwidth
    - used by > and < commands
    - defaults to off

Paste
  p  - paste after cursor
  P  - paste before cursor
  ]p - paste with indentation adjustment (for source code)
  * To paste text from another application that was copied
    to the system clipboard and retain its indentation
    - :set paste!
    - cmd-v (without being in insert mode)
    - :set paste!

Pathogen
- better way to install Vim plugins
- add these lines to .vimrc
  call pathogen#infect()
  call pathogen#helptags() " generates help documentation for plugins
- create a directory under the ".vim" directory named "bundle"
- use "git clone {url}" in that directory to install plugins
- to use the plugin, either restart vim or
  :source ~/.vim/bundle/{plugin-name}/plugin/{plugin-name}/vim
- see https://github.com/tpope/vim-pathogen
- also consider Vundle

Python
- some plugins require Vim to be built with Python support
  * Cygwin Vim doesn't have this by default
- steps to build
  install Mercurial if not already installed ("brew install hg" on Mac OS X)
  hg clone https://vim.googlecode.com/hg/ vim
  cd vim/src
  ./configure --enable-multibyte --without-x --enable-gui=no --enable-pythoninterp=yes
  make
  make install
  ln -sf /usr/local/bin/vim.exe /usr/bin/vim

Quickfix List (also see Location List)
- list of records containing filename, line number, and optional column number
- typically produced by a compiler or linter
  * ex. :!jshint
  * automatically updated as issues are fixed (at least with jshint)
- many tools that populate the quickfix list do not open it
  and automatically jump to location of first record
- to skip to the next or previous record location, :cn[ext] or :cp[revious]
  * can repeat last ex command with @:
  * can repeat last macro with @@
  * so :cn @: @@ @@ @@ visits next five
- to skip to the first or last record location, :cfir[st] or :cla[st]
- when list contains references to more than one file,
  it can be useful to skip to those for the next or previous file
  * to skip to first record in next file, :cnfile
  * to skip to last record in previous file, :cnprev
- to view all records, :cope[n]
- you configured <leader>q to toggle viewing quickfix list
- to jump to record reference under cursor, press <cr>
- to close quickfix list, :ccl[ose]
- there is only one current quickfix list,
  but others are saved in a stack
  * to switch to the previous one, :colder
  * to switch to the newer one, :cnewer
- recommended plugin: unimpaired (see separate section)

Reflow text in a paragraph
- position cursor anywhere in a paragraph and
  enter gqap (leaves cursor on first line of next paragraph)
  or gqip (leaves cursor on blank line after paragraph)
  * seems to default to a max line width of 80 characters
- in code this puts all lines in a function on one line
  if it fits within line length

Registers
- like named clipboards
- hold text that can be pasted
- to place text in a specific register,
  precede yank or delete command with "{register-name}
  where register name is a-z (note the double-quote!)
  * if an uppercase register name is used, the text is appended to the
    text already in the register with the corresponding lowercase name
- when yank or delete command is used without a register name,
  the "unnamed register" is used
- to paste text from a register
  * in normal mode, "{register-name}p
  * in insert mode, ctrl-r{register-name}
- register 0 holds the text from the last yank
- registers 1 to 9 hold the most recent deletes
- register % holds the current filename
- register # holds the previous filename that was being edited
- register / holds the last search text
- register - holds the last "small" delete text (less than a line)
- register . holds the last inserted text
- register : holds the last ex command entered
- :reg to see contents of all registers
- :reg {names} to see contents of all registers
- register contents are stored in ~/.viminfo
  and restored when Vim is restarted

Regular expressions
- slightly different than other regular expressions
- see "very magic" regex parsing mode
- quantifiers
  * \= means zero or one of preceding
  * * means zero or more of preceding
  * \+ means one or more of preceding
- for more, see http://vimregex.com and
  http://vim.wikia.com/wiki/Search_across_multiple_lines

Reverse order of lines
- all lines in file
  :g/.*/m0 - for all lines, move it to line zero
  * can also do this from bash with
    tac {filename} > {new-filename}
    - tac is the reverse of cat
- selected lines
  * select lines and enter !tac

Ruby Support
- some plugins require Vim to be built with Ruby support
  * describe how to do this
- cd ~/.vim/bundle
- git clone https://github.com/vim-ruby/vim-ruby.git
- add the following to .vimrc
  set nocompatible      " We're running Vim, not Vi! (default setting)
  syntax on             " Enable syntax highlighting
  filetype on           " Enable filetype detection
  filetype indent on    " Enable filetype-specific indenting
  filetype plugin on    " Enable filetype-specific plugins
- the previous three lines can be written as
  filetype indent plugin on

Search and Replace
  :set incsearch - move to search matches while typing search string
  :set hlsearch - highlight all matches after pressing Enter
  :set ic - case-insensitive searches
  :set noic - case-sensitive searches
  /{pattern} - search forward for next occurrence, cursor placed at match start
  /\c{pattern} - same as previous, but case-insensitive
  /{pattern}/e - same as previous, but cursor placed at match end
  ?{pattern} - search backward for previous occurence
  * - search forward for next occurence of word under cursor
  # - search backward for previous occurence of word under cursor
  :noh[lsearch] - turn off highlighting of matches from last search
  n - repeat last search
  N - repeat last search in opposite direction (use ctrl-p in insert mode?)
  * - search forward for next occurrence of word under cursor
  # - search backward for next occurrence of word under cursor
  :%s/{pattern}/{string} - replace first occurrence of {pattern} with {string}
  * to remove trailing whitespace from all lines, %s/\s\+$//
  * to add space before open braces, %s/\(\w\){/\1 {/
    - capture groups are surrounded by \( \)
    - backreferences to capture groups are \1, \2, ...
  :%s/{pattern}/{string}/g - all occurrences
  :%s/{pattern}/{string}/gc - all occurences with confirmation prompts
  :%s/\t/  /g - replace all tabs with two spaces
  :set ff=unix - removes Windows carriage returns from all lines
  :%s/ctrl-vctrl-m$//g - also removes Windows carriage returns from all lines
                         and is sometimes needed instead of the previous
  :%s/ctrl-vctrl-m/ctrl-vctrl-m/g - replaces Windows carriage with Unix ones
  :.,$s/{pattern}/{string}/g - all occurrences from the cursor to end of file

Select in visual mode
- highlights selected text
  v - begin visual selection in char mode;
      now move cursor to end of selection;
      includes char under cursor;
  V - begin visual selection in line mode
  ctrl-v - begin visual selection in block mode
  o - changes end of selection being moved
- after selecting a region, can use commands like
  yank (y), delete (d), and paste (p)
- substitutions in visual mode only affect selected lines
  :'<,'>s/old/new/

Shell commands
- see Conque at http://code.google.com/p/conque/
- not really useful when running Vim in tmux
- may need to install newer version of python (works with 3.2.1)
- download and unzip into .vim/bundle directory
- to run a bash shell in current Vim buffer, :ConqueTerm bash
- other examples
  :ConqueTermSplit mysql -h localhost -u joe -p sock_collection
  :ConqueTermTab bash
  :ConqueTermVSplit bash
- when running Vim from a terminal window,
  can press ctrl-z to put Vim in the background
  and enter fg to return to Vim in the foreground

Silver Searcher, The
- to install
  * for Cygwin-specific steps, see https://gist.github.com/k-takata/5124445
    - copy the following file to /usr/local/bin:
      /usr/i686-pc-mingw32/sys-root/mingw/bin/pthreadGC2.dll
  * git clone https://github.com/ggreer/the_silver_searcher.git
  * cd the_silver_searcher/
  * ./build.sh
  * strip ag
  * make install (copies ag.exe to /usr/local/bin)
- to use from shell, outside of Vim
  * ag search-term file-path
    - search-term can be a string or regular expression surrounded by /'s
    - file-path can contain ** to recursively search subdiretories
      and * for wildcard
- to configure to be used by Vim commands grep and lgrep, and ctrlp plugin
  add the following to .vimrc
  if executable('ag')
    " Use ag instead of grep.
    set grepprg=ag\ --nogroup\ --nocolor\ --column
    set grepformat=%f:%l:%c:\ %m

    " Use ag in CtrlP for listing files.
    " It is lightning fast and respects .gitignore.
    let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

    " ag is fast enough that CtrlP doesn't need to cache.
    let g:ctrlp_use_caching = 0
  endif

Slime and Screen
- to install vim-slime
  * install Pathogen if not already done
  * cd ~/.vim/bundle
  * git clone git://github.com/jpalardy/vim-slime.git
  * restart Vim?
- on a Mac, screen is already installed
- to use
  * open a Terminal window
  * enter "screen -S {session-name}" to start a screen session (ex. name is node)
  * start Vim
  * open a file
  * position the cursor in a block of lines (forward and backward to a blank line)
    or select the lines to be copied
  * press ctrl-c ctrl-c to copy it to a screen session
  * the first time this is done, slime will prompt for a screen session name
    - enter a name (like "node")
    - press return a second time to accept the screen window name of "0"
  * the code will be copied to the screen session
- common use case
  * start a REPL in the screen session (such as node)
  * open a JavaScript file in Vim
  * position the cursor in a function definition
  * press ctrl-c ctrl-c to copy the function definition into the REPL
  * test the function by enter a call to it in the REPL

Snipmate
- also see "UltiSnips" section which is probably better
  * recommended by Drew Neil
  * you are using UltiSnips now instead of this!
- to install
  * cd ~/.vim/bundle
  * git clone https://github.com/tomtom/tlib_vim.git
  * git clone https://github.com/MarcWeber/vim-addon-mw-utils.git
  * git clone https://github.com/garbas/vim-snipmate.git
  * git clone https://github.com/honza/vim-snippets
  * cd vim-snipmate
- to use
  * enter a snippet name in insert mode and press tab key to expand
  * won't work if tab key has been mapped to do something else!
  * press tab to advance to next placeholder in snippet if there is one
- to modify and add snippets
  * edit the .snippet files in .vim./bundle/vim-snippets/snippets
    - for example, javascript.snippets
  * indentation in snippets must be done with tabs, not spaces
    - depending on other Vim configuration,
      tabs can expand to spaces when a snippet is used

Spell check
- to start, enter
  :setlocal spell spelllang=en_us
  * you have <leader>s mapped to toggle this in normal and insert modes
- to jump to next error, ]s
- to jump to previous error, [s
- to get list of suggested replacements, z=
  * enter number of replacement and press <cr>
    or just press <cr> to make no change
  * window of replacements hides document which seems bad
- to repeat the replacement made by z= throughout the document, :spellr
- to correct mispelled words while in insert mode, press ctrl-x s
  * get a dropdown list of suggestions rather than
    a window that hides the document which seems better
  * searches backward for a mispelled word
  * press ctrl-n and ctrl-p to select the next and previous suggestions
  * press ctrl-y to accept the selected suggestion
  * press ctrl-e to exit without changing the word
  * you mapped <leader>S to switch to insert mode and press ctrl-x s,
    but you really want it to automatically press ctrl-x s again
    after a word is corrected
  * it would also be nice to correct words going forward
    instead of backward
- to add word under cursor to list of good words, zg
  * adds to ~/.vim/spell/en.utf-8.add
- to remove word under cursor from list of good words, zw
- to add a word file for specialized jargon like computer terms,
  setlocal spellfile+=~/.vim/spell/{name}.utf-8.add
- for more see http://vimdoc.sourceforge.net/htmldoc/spell.html

Splits
- see "Windows" below

Status Line
- can configure contents
- spaces must be escaped with a backslash
- my preferences are:
  set statusline=%t " file name (omits path)
  set statusline+=%M " modified flag
  set statusline+=%R " read-only flag
  set statusline+=%{ALEGetStatusLine()} " Asynchronous Lint Engine
  set statusline+=%= " left/right side separator
  (right aligns all the content that follows)
  set statusline+=line\ %l " current line number
  set statusline+=\ of\ %L " total lines
  set statusline+=,\ col\ %c, " cursor line number and column
  set statusline+=\ %P " percent through file
  set laststatus=2 " always display status line
  " change status line background color based on mode
  highlight StatusLine ctermfg=red ctermbg=white
  autocmd InsertLeave * highlight StatusLine ctermfg=red ctermbg=white
  autocmd InsertEnter * highlight StatusLine ctermfg=darkgreen ctermbg=white
- %f shows the file name of the current file
- there are also plugins that give a nice status line
  * consider using vim-airline

Surround plugin
- operates on the things (delimiters) that surround text,
  not on the text inside them
- adds, deletes, and changes surroundings (delimeters)
- delimeters can be ' " ` ( ) { } [ ]
  and HTML/XML tags (not angle brackets <>)
- in descriptions below
  * when {new} is (, {, or [, a space will be added inside them
  * when {new} is ), }, or ], no space will be added inside them
- to add surroundings to text selected in visual mode (V or v)
  * select text and press S{new}
  * ex. to surround selected text with double quotes,
    select it and press S"
  * ex. to surround selected text with a div tag,
    select it, enter S<div>
    - can also press return instead of typing closing >
  * ex. to surround selected text with a p tag that has attributes,
    select it, enter S<p id="foo" class="bar">
- to add surroundings to text specified with a text object
  ys{text-object}{new}
  * text-object selects the text to be surrounded
  * ex. to add double quotes, ysiw"
  * ex. to add double quotes around the next three words, ys3w"
  * ex. to add a div tag around the current paragraph, ysip<div>
- to change surroundings, cs{current}{new}
  * ex. to change double quotes to single quotes, cs"'
  * ex. to change double quotes to a div tag, cs"<div>
  * ex. to change current surrounding tag to a div tag, cst<div>
  * ex. to change current surrounding tag to braces,
    - cst{ and press return (includes a space inside { and })
    - cst} and press return (no space inside { and })
- to delete surroundings, ds{current}
  * ex. to delete double quotes, ds"
  * ex. to delete the surrounding tag, dst
    - even deletes attributes in start tag
- see https://github.com/tpope/vim-surround
- install repeat.vim plugin so the dot (.) command
  will repeat these commands in another location

Syntastic
- to see the checkers being used for the filetype of the current buffer
  * :SyntasticInfo
- to configure to only use eslint for JavaScript files
  * let g:syntastic_javascript_checkers=['eslint']
  * this is currently the best option for React JSX support
  * need to configure jsx support in .eslintrc

Tab Pages
- to open a new, empty tab, :tabe[dit]
  * can then select a file with :E
- :Te - open new tab and explore in it
- to open a new tab for a specified file, :tabe[dit] {filepath}
  * can be just the name of a file in current directory
- to open all buffers in separate tabs (up to tabpagemax), :tab ball
- to close current tab, :tabc[lose]
- to close all other tabs, :tabo[nly]
- to navigate to
  * next tab, :tabn[ext] or gt (in normal mode)
  * previous tab, :tabp[revious] or gT (in normal mode)
  * first tab, :tabf[irst]
  * last tab, :tabl[ast]
  * given tab number (starting from 1), :{number}gt
  * specific tab, click with mouse
- to have tabs always show even when there is only one window,
  add the following to _vimrc
  set showtabline=2
- to use a tab to edit a file opened using "Edit with Vim"
  from the Windows Explorer context-sensitive menu,
  add " -p" to the Windows registry under
  HKEY_LOCAL_MACHINE\SOFTWARE\Vim\Gvim\path using regedit

Tabs
- to automatically add spaces when a tab is typed,
  * set expandtab
- to insert a real tab character even when the expandtab option is set
  * ctrl-v tab
- to make it easy to see where tab characters are in a file
  * set listchars=tab:»·,trail:·
  * uses unicode characters which requires support for
    multi-byte characters to be compiled into Vim
    - seems to be the default now
    - to verify, enter "vim --version" and look for "+multi-byte"
  * renders tab characters with a right-pointing double angle
    followed by middle dots to show where the tab stop ends
  * also renders trailing spaces with middle dots

Tags
- "Ctags generates an index (or tag) file of language objects
  found in source files that allows these items to be quickly
  and easily located by a text editor or other utility."
  * such as definitions of functions, classes, and methods,
    not calls to them
- to determine whether Exhuberant Ctags is installed,
  as opposed to plain ctags
  * ctags --version
- to install Exuberant Ctags on Mac OS X, brew install ctags
  * understands 41 language syntaxes including
    C, C++, C#, HTML, Java, JavaScript, Lisp, Lua, Perl, Python,
    Ruby, shell scripts, and VimScript
    - not CSS
- to generate a "tags" file for the current directory and all subdirectories,
  enter "ctags -R"
  * to use with YouCompleteMe, "ctags -R --fields=+l" (lowercase L)
  * will get lots of warnings that say "ignoring null tag in ..."
    for JavaScript files
- helping Vim locate "tags" file
  * by default, will look in directory where Vim was started
  * can add other directories with :set tags={path-list},
    but it's easiest to just start in the correct directory
- to visit a tag in Vim, do one of the following:
  1) :ta[g] {tag}
     * visits highest priority (closest) match
  2) position cursor over tag-string and press ctrl-]
     * visits highest priority (closest) match
     * This is the default telnet escape character.
       To avoid escaping to a telnet prompt,
       include the -E option when starting telnet to disable escaping.
  3) if there might be more than one match, press g-ctrl-]
     to get a menu of matches to pick from
- maintains a history of visited tags (stack)
- to return to the previous location, press ctrl-t
- to start vim and immediately visit a given tag,
  vim -t {tag}
  * when there is more than one match,
    Vim displays all matches and allows one to be selected by number
- for more info, :help tags

Tern for Vim plugin
- provides Tern-based JavaScript editing support in Vim
- built on Node.js which isn't currently supported in Cygwin
- Tern is a code-analysis engine for JavaScript
  * see http://ternjs.net
  * commands include TernDef (ctrl-o to return to previous location),
    TernDefPreview, TernDefSplit, TernDefTab, TernDoc,
    TernDocBrowse, TernType, TernRefs, and TernRename
  * for help on Tern, :h Tern
- to install with Pathogen
  * cd .vim/bundle
  * git clone https://github.com/marijnh/tern_for_vim.git
  * install Node.js if npm command isn't available
  * cd tern_for_vim
  * npm install

Text Objects in editing commands
- operate on text as units other than individual characters
  * words, lines, sentences, paragraphs
- can be undone with the dot command
- new text objects can be defined
- text objects are not available in shell
  * to edit current shell command in Vim,
    press <esc>v, edit, and enter :wq
    to exit Vim and execute the edited command
    - can't seem to avoid executing the command on exit!
  * can simulate in shell with vi-command keymap at
    https://github.com/minos-org/bash-minos-settings/blob/master/etc.inputrc
- editing commands have two to four parts
  1) count (optional)
     can follow command, but not usually entered that way
  2) command
     d - delete (cut)
     c - change (same as d, but enters insert mode)
     y - yank (copy)
     v - visually select
     < - indent
     > - outdent
  3) motion (also see "Moving Around" section)
     - optional for some text objects to start from cursor
     a - all (includes delimiters)
     i - inner (excludes delimiters)
     t - 'til a character forward (excludes character)
     T - 'til a character backward (excludes character)
     f - find character forward (includes character)
     F - find character backward (includes character)
     /{text}<cr> - search forward for text (excludes text)
     ?{text}<cr> - search backward for text (includes text)
     {n}j - current line plus n lines after (n + 1 lines)
     {n}k - current line plus n lines before (n + 1 lines)
     - n defaults to one, so at least two lines are affected
     - ex. to change current line plus two more, c2j
     - using :set relativenumber makes these easier
       by displaying relative line numbers
  4) text object
     b - current location to beginning of word (can omit motion)
     e - current location to end of word (can omit motion)
     w - word (can omit motion)
     W - big word (delmited by whitespace) (can omit motion)
     s - sentence (requires motion)
     p - paragraph (requires motion)
     t - tag (HTML/XML) (requires motion)
     ( ) { } [ ] < > ' " ` - by delimiter
     * ( and ) mean sentence when motion is omitted
     * { and } mean paragraph when motion is omitted
     * [ ] < > ' " require motion
     * can use < and > to operate on start and end tags
     % - delimited text including delimiters
     * cursor must be on a delimiter
     * cannot specify motion
     * acts weird if a count is specified
- also see Surround plugin documented here
- examples
  * diw - delete inner word
  * caw - change all word
  * yi( - yank text inside parens
  * d} - delete to end of paragraph
  * d{ - delete to beginning of paragraph
  * d/^$<cr> - delete to next blank line
- moving cursor
  w - moves to beginning of next word
  W - moves to beginning of next big word
  b - moves to beginning of previous word
  e - moves to end of current or next word
  ( - moves to beginning of previous sentence
  ) - moves to beginning of next sentence
  { - moves to line before previous paragraph
  } - moves to line before next paragraph
  % - moves to matching delimter
  * if not on a delimeter, moves forward to next delimiter

Tools that use vi
- to cause tools that launch vi (such as cleartool edcs)
  to launch Vim instead, set VISUAL environment variable to "vim"

TypeScript
- compiler options are described at
  https://github.com/Microsoft/TypeScript/wiki/Compiler-Options
- Tsuquymoi plugin
  * https://github.com/Quramy/tsuquyomi
  * works as a client for TSServer, an editor service bundled into TypeScript
  * must have tsserver running (in TypeScript bin directory which is in PATH)
  * create tsconfig.json in project root directory
    - see https://github.com/Microsoft/TypeScript/wiki/tsconfig.json
    - also see http://json.schemastore.org/tsconfig
  * when a buffer is saved and there are errors
    - only checks for errors on save
    - lines with errors have red >> in gutter
      * more cursor to line to see error message in status area
    - errors are written to quickfix list
      * you configured <leader>q to toggle display
  * ctrl-x ctrl-o - in insert mode, show completions
  * ctrl-] - go to definition of symbol under cursor
  * ctrl-t - return to location where ctrl-] was pressed
  * ctrl-^ - show list of locations where symbol under cursor is referenced
    - navigate list with up and down arrows
      and press return to navigate to reference
  * <leader>r - renames symbol under cursor and
    all references, even in files that aren't
    currently opened in Vim (it opens them)
  * <leader>t - gives hints about symbol under cursor in status area
- syntax highlighting plugin
  * https://github.com/leafgarland/typescript-vim

UltiSnips
- to install
  * cd ~/.vim/bundle
  * git clone https://github.com/SirVer/ultisnips
  * git clone https://github.com/honza/vim-snippets
- to configure, add these lines to .vimrc
  let g:UltiSnipsExpandTrigger="<tab>"
  let g:UltiSnipsJumpForwardTrigger="<tab>"
  let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
  nnoremap <leader>es :UltiSnipsEdit<cr>
  * previous line edits private snippet file for current filetype
  * these mappings conflict with the YouCompleteMe plugin
    - consider using <c-j> instead of <tab>
      and <c-k> instead of <s-tab>
    - to do this, add these lines to .vimrc
      let g:UltiSnipsJumpForwardTrigger="<c-j>"
      let g:UltiSnipsJumpBackwardTrigger="<c-k>"
- to use
  * enter a snippet name in insert mode and press tab key to expand
  * won't work if tab key has been mapped to do something else!
  * press tab to advance to next placeholder in snippet if there is one
- to modify and add snippets
  * default snippet files are in .vim/bundle/vim-snippets/UltiSnips
    - for example, javascript.snippets
  * my snippet files are in MyUnixEnv/UltiSnips
  * to edit a private snippet file for the current filetype
    - :UltiSnipsEdit
    - if the file doesn't exist, it is created
    - these files are saved in .vim/UltiSnips/{filetype}.snippets
- snippet definitions
  * can contain shell commands in backticks
    snippet today
    Today is `date "+%B %d %Y"`
    endsnippet
  * can contain VimScript expressions in backticks with !v at beginning
  * can contain Python code in backticks with !p at beginning
    - can reference preset variables including:
      * path - path to current file
      * fn - current filename
      * t - placeholder value array (ex. t[1])
      * cur - current text in placeholder
    - example for simple JavaScript logging
      * setting snip.rv sets the return value for the current snippet
      snippet log
        console.log('`!p snip.rv = fn` ${1:function}: ${2:expression} =', $2);
      endsnippet

Unicode
- to enter accented characters, <c-k>{letter}{accent}
  * ex. for accute e, <c-k>e>
- to find the code for the character under the cursor, press ga
  * the decimal, hex and octal values will be
    displayed in the status line
- to find a unicode character by its code,
  :f/\%d{decimal-value} THIS IS WRONG!
- To substitute all occurences of a unicode character
  with another character,
  s/\%d{decimal-value}/{new-char}/g

Unimpaired Plugin
- https://github.com/tpope/vim-unimpaired
- provides 20 key mappings in four categories
- for a full list, :h unimpaired
- all take a count
- highlights
  * files
    - ]f and [f open next and previous file in
      directory of current file in alphabetical order
  * buffers
    - ]b, [b, ]B, and [B for bnext, bprevious, blast, and bfirst
  * quickfix list
    - first need to run a command that populates the quickfix list
    - ]q, [q, ]Q, and [Q for cnext, cprevious, clast, and cfirst
    - ]ctrl-q and [ctrl-q for cnfile (next file), cpfile (previous file)
      * must disable control flow in terminal with stty -ixon
  * location list
    - first need to run a command that populates the location list
    - ]l, [l, ]L, and [L for lnext, lprevious, llast, and lfirst
    - ]ctrl-l and [ctrl-l for lnfile (next file), lpfile (previous file)
  * argument list
    - if not already populated, do that with :args ...
    - ]a, [a, ]A, and [A for next, previous, last, and first
  * ctags
    - first need to navigate to a definition with ctrl-]
    - ]t, [t, ]T, and [T for tnext, tprevious, tlast, and tfirst

URL
- in normal mode with cursor over a URL,
  press gx to open URL in default web browser

vim-airline plugin
- stopped using because excess content to left of file name
  causes file name to be obscured in narrow, vertical splits
- a rewrite of the powerline plugin that is
  implemented in VimScript instead of python
  and is easier to install
- to install, git clone https://github.com/bling/vim-airline.git
- to setup Powerline fonts, see
  https://coderwall.com/p/yiot4q/setup-vim-powerline-and-iterm2-on-mac-os-x
- to enable other plugins to customize the statusline
  for specific file types (ex. mpdv),
  tell airline to exclude those file types
  * create ~/.vim/plugin/airline.vim
  * add the following line:
    let g:airline_exclude_filetypes = ['mpdv']

vimgrep (also see grep)
- searches files in and below current directory (slow!)
- doesn't use an external shell command
- :vim[grep] {pattern} {files}
  * pattern can be a regex surrounded by /'s
  * files can use * wildcard to match zero or more characters
  * files can use ** to recursively search subdirectories
  * populates quickfix list
    - use :lvim[grep] to populate location list instead
    - can use "unimpaired" plugin key mappings to navigate
  * ex. vim parseInt **/*.js
  * first matching file is opened
    - based on file type, that could trigger another command that
      creates a new quickfix list (such as jshint)
      * best way to avoid this issue is probably to use lvimgrep instead
        which populates a location list instead of the quickfix list
      * to stop jshint from running on each .js file when it is opened,
        add this to .vimrc:
        let JSHintUpdateWriteOnly = 1
      * to toggle use of jshint, run :JSHintToggle
        - only a known command after first .js file is opened
    - to return to the quickfix list created by vimgrep, :colder
    - to avoid opening first matching file,
      use vimgrep! instead of vimgrep

vim-vinegar
- enhances use of netrw plugin
- hides informational lines at top of directory listing
  * press I to toggle them on and off
- improves file sorting
- press - to go up to parent directory
- press ~ to go to home directory
- press . to populate end of : command line with file name under cursor
- press ! to populate end of : command line with file name under cursor and start with !

Vundle
- alternative to Pathogen

vim-js-arrow-function
- press <leader>af to convert a JavaScript non-arrow function to an arrow function
- press <leader>tb to toggle use of braces in an arrow function
  which is useful when changing a function from having one statement to many
  or vice versa

vim-tag-comment
- press <leader>tc to comment the entire elment (start to end tag) under the cursor
- press <leader>tu to uncomment the entire element (start to end tag) under the cursor
- press <leader>tC to comment the tag (start or end) under the cursor
- press <leader>tU to uncomment the tag (start or end) under the cursor

Windows (created by splits)
  :win {width} {height} - to set default gvim window size (put in .vimrc);
  :sp[lit] [{name}]  - horizontal split screen into two windows
                       and optionally open file {name}
  :Se                - horizontal split screen and explore
  ctrl-w s           - same as :split
  :vs[plit] [{name}] - vertical split screen
  :Ve                - vertical split screen and explore
  ctrl-w v           - same as :vsplit
  :new               - split screen and start new file
  ctrl-w n           - same as :new
  ctrl-w {h|j|k|l}   - move to window in direction of key
  ctrl-w {H|J|K|L}   - swap windows in direction of key
                       * H and L switch from horizontal to vertical splits
                       * J and K switch from vertical to horizontal splits
  ctrl-w r           - rotate windows
  ctrl-w down-arrow  - move to window below
  ctrl-w up-arrow    - move to window above
  ctrl-w _           - maximize height of current window (decreases others to one line)
  ctrl-w |           - maximize width of current window (decreases others to one column)
  ctrl-w ctrl-w      - move to next window
  :clo[se]           - close current window (doesn't delete buffer)
  :clo[se]!          - close current window and discard changes
  ctrl-w c           - same as :close
  :on[ly]            - close all windows but current one
  ctrl-w o           - same as :only
  ctrl-w =           - make split windows equal width or height
  {n}ctrl-w <        - decrease window width by {n}
  {n}ctrl-w >        - increase window width by {n}
  {n}ctrl-w +        - increase window height by {n}
  {n}ctrl-w -        - decrease window height by {n}

Working Directory
- to see, :pwd
- to change, :cd {path}
  * :cd .. to go up to parent directory
  * :cd - to return to previousl working directory
  * :cd %:h - to change directory to that of the file in the current buffer
  * enter :cd and press tab key to cycle through subdirectory names
- affects filename completion

YouCompleteMe (YCM)
- a fuzzy-search code completion engine for Vim.
- see https://github.com/Valloric/YouCompleteMe
- makes Vim startup very slow!
  * probably due to time required to start the Python-based YCM server
  * starts a new Python process for each Vim session
- uses several completion engines
  * integrates with Vim's Omnicomplete and Exhuberant Ctags
  * determines which to use based on context
- keys
  * don't have to press any key to get suggestion list; appears automatically
  * to further filter suggestion list, continue typing
  * press tab or down arrow to select first suggestion
  * press tab or down arrow repeatedly to move to next suggestion
  * press shift-tab or up arrow to move to previous suggestions
  * to accept selected suggestion, just continue typing
  * press ctrl-space to get context-specific suggestions
    even if no characters have been entered
- suggestions are based on typed characters appearing in order in them
  * ex. typing "cm" could suggest YouCompleteMe
  * typed lowercase letters match any case, but
    typed uppercase letters only match uppercase letters
  * matches at word boundaries appear higher in suggestion list
    - first letter of each word (my word boundaries)
    - uppercase letters in camel-cased words (myWordBoundaries)
    - match the examples above by typing "mwb" or "wb"
- provides programming language-specific semantic completions
  * ex. type ., ->, or :: to get possible property/method names
  * more support for C-family langauges and Python than others
    - uses omnifunc for languages without a semantic completion engine
  * JavaScript example
    - enter "document." to get a list of all methods on the document object
- file-name completion to insert file names in file being edited
  * type ./ or ../ to begin
  * not used for all file types (ex. not in .txt files)
- to install
  * cd .vim/bundle
  * git clone https://github.com/Valloric/YouCompleteMe.git
  * cd YouCompleteMe
  * git submodule update --init --recursive
  * install CMake
    - on Mac OS X, brew install cmake
    - in Cygwin, is install through setup-x86.exe
  * this plugin has a compiled component
    - cd ~/.vim/bundle/YouCompleteMe
    - ./install.sh
    - this option fails in Cygwin: --clang-completer
- integrates with UltiSnips
  * but use of tab key conflicts
    - see key mapping suggestions in UltiSnips section
- to enable completion inside comments,
  let g:ycm_complete_in_comments = 1
- to enable completion inside strings,
  let g:ycm_complete_in_strings = 1
- to collect identifiers (possible completions) from comments and strings
  let g:ycm_collect_identifiers_from_comments_and_strings = 1
- to collect identifiers from tags files
  let g:ycm_collect_identifiers_from_tags_files = 1
  * requires use of Exhuberant Ctags, not plain Ctags
  * must generate tags file with  "ctags -R --fields=+l" (lowercase L)
  * makes Vim unusably slow and causes an error on all completions!
    - error is "-- User defined completion (^U^N^P) Pattern not found"
- mailing list: Google Groups ycm-users

Other
  :h[elp] {topic} - get help
    To navigate to topics surrounded by vertical bars
    put cursor on topic and press ctrl-]
  ~ - change case of char under cursor or every character
      selected in visual mode
  J - join current line with next line
  u - undo last change
  U - undo all changes on current line
  ctrl-r - redo last undo
  :earlier 15m
  - reverts the document back to how it was 15 minutes ago
  - can take various arguments for the amount of time you
    want to roll back, and is dependent on undolevels
  - can be reversed with the opposite command :later
  ctrl-l - refreshes display (useful if it gets scrambled)
  . - repeat last non-colon (ex) command
  :hardcopy - sends to printer
  :set nu[mber] - displays line numbers (you mapped <leader>n to toggle this)
  :set nonu[mber] - undisplays line numbers
  :set relative - displays relative line numbers (from current line)
  - current line gets absolute line number
  :set norelative - undisplays relative line numbers
  :set et or expandtab - future tabs are expanded to spaces
  :retab - expands all tabs currently in file to spaces
           if the previous option is set
  :!{os-cmd} - executes an OS command from within Vim (ex. :!ls)
  @: repeats the last ex command
  :so[urce] {file} - executes a file containing Ex commands such as .vimrc
  - you have <leader>ev mapped to edit .vimrc
    and <leader>sv mapped to source .vimrc
  :set wm=5 or wrapmargin -
    sets the wrap margin so that text automatically wraps
    as it is entered when it is less then 5 characters
    from the right edge of the window
    To disable, set textwidth to zero with ":set tw=0".
  :make - runs Makefile in current directory
  gd - go to definition of method or variable under cursor
  K - go to man page for word under cursor
  ctrl-g - display name of file being edited, # of lines, % thru
  % - find matching {}, () or []
  To avoid line wrap
    :set nowrap textwidth=0 wrapmargin=0
  To wrap lines at the window edge
    :set wrap nolinebreak textwidth=0 wrapmargin=0
  To break lines with hard line breaks and make them <= 80
    :set textwidth=80
  To send a buffer to a shell command
    :w !{command}
    For example, to execute Ruby code in a buffer, :w !ruby
    Can map the following to a key to save all open files
    and run the current buffer.
    :wall<CR>:!ruby %<CR>

Notes from Bill Odom's talk on 2/16/12

Google "recommended Vim plugins for JavaScript coding"
#1 JavaScript indenter - by Preston Koprivica
#2 Vastly improved javascript indentation - by Darrick Wiebe
default syntax highlighting for JavaScript just uses highlighting for C?
JSLint - see link from crypticswarm blog to Jonathan Palardy page
JSHint - manalang jshint.vim - is this what you are using?
see "Resources" slides in his deck
Bufexplorer
Taglist - works with exuberant-ctags; runs it for you
DoctorJS - from Mozilla; tags JavaScript source files
Yehuda Katz article "Everyone Who Tried to Convice Me to use Vim was Wrong"
- Bill doesn't like his recommended list of plugins for newbies
See Steven Pritchard's minimal Vim environment
http://vimcasts.org/ - a book is in the works
