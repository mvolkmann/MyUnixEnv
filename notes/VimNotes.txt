Vim Notes

Learning from scratch
- run vimtutor

Starting
- vim [filename]          - to start in a specified file
- vim +E                  - to start in file explorer
- vim .                   - same as vim +E, but not in Cygwin
- vim --remote {filename} - to edit file in existing vim session
                            (doesn't work on Mac OS X)
- vim -u NONE             - start without configuration in .vimrc
- vim --noplugin          - start without loading plugins

Help
- for help on any topic, :h[elp] {topic}
- a good place to start is :help index
- for general help, :help user-manual
- for help on version 7 features, :help version7
- if topic name isn't known, :helpgrep {guess}
  then open quickfix list with :copen
  which you mapped to <leader>q
- to navigate a link in help,
  position cursor over link and press ctrl-]
  or double-click
- to return to previous location, press ctrl-t

Configuration is specified in
- .vimrc under Unix
- _vimrc under Windows
- typically stored in home directory
  - ~ under Unix
  - C:\users\{user-name} in Windows
- to see location of current vimrc file, :echo $MYVIMRC
- it is recommended to use full command names
  rather than abbreviations in this file

---

Installing Vim
- from source
  * download source
    - hg clone https://vim.googlecode.com/hq/ vim
  * build
    - cd vim/src
    - ./configure --enable-rubyinterp --enable-pythoninterp
      * Ruby is needed by some plugins such as Command-T
      * Python is needed by some plugins such as YouCompleteMe
    - make; make install

- under Windows
  * download gvim74.exe from http://www.vim.org "Download" link
  * double-click the .exe file
  * for better Ruby support,
    - add the following to C:\Vim\_vimrc
      autocmd FileType ruby,eruby
      set omnifunc=rubycomplete#Complete
    - from a command prompt, run "gem install vim-ruby
    - download rubycomplete.vim from
      http://blog.hasno.info/blog/segfault/dev/2006/04/10/
      vim-7-ruby-omni-completion.html
      into C:\Vim\vim70d\autoload

- under Linux
  * download source from http://www.vim.org
  * bunzip2 vim-6.3.tar.bz2
  * ./configure
  * make GUI=yes
  * make install (as root)
  * to run GUI version, enter "gvim"

--- Alphabetized topics start here

Abbreviations
- typically used in insert mode
- to define, :iabbrev {abbreviation} {full-text}
  * to make buffer local, :iabbrev <buffer> {abbreviation} {full-text}
    - useful in autocmds for the FileType event
    - see example in AutoCommands section
- to use, type abbreviation in insert mode
  followed by a space (or any character not allowed in a keyword)
  which triggers expansion
  * to see list of keyword characters, :set iskeyword
  * keyword characters include letters, digits, _,
    and some special characters (192 to 255)
- examples
  * :iabbrev @@ r.mark.volkmann@gmail.com
  * :iabbrev rmv R. Mark Volkmann

ALE
- Asynchronous Linting Environment
- see ALENotes.txt

Argument List
- initially set to expanded list of files passed to vim from command-line
  * ex. vim **/*.js **/*.css
- repopulate with :args {list}
  where list is space-separated and can contain wildcards
  and ** to recurse into subdiretories
  * ex. :args **/*.js **/*.css
- to run an ex command on each file, :argdo {command}
  * can specify multiple commands separated by |
- :next or :previous to jump to next or previous file
- :last or :first/:rewind to jump to last or first file

AutoCommands
- register specified commands to be run when certain events occur
- for grouping commands in a namespace that are
  executed when specified events occur
- syntax:
  au[tocmd] [group] {events} {pattern} [nested] {cmd}
  * if multiple event names are specified, separate them by commas
- usually want these to be in a group
- examples
  * set tabstop for HTML files
    autocmd FileType html setlocal tabstop=2 (verify this from Perrin's notes)
    - could use filetype support (different file for each type) instead
  * if no file specified when Vim is started, start netrw Explore
    autocmd VimEnter * :if argc() is 0 | Explore | endif
  * if an image file is opened in Vim, open it in a web browser
    - ex. when opening from netrw Explore
    autocmd FileType image call system('git web--browse ' . shellescape(expand($.p')))
    - could use "open" instead of "git web--browse" on a Mac
  * add an abbreviation for a specific filetype
    - alternative to using SnipMate or UltiSnips
    - autocmd FileType javascript :iabbrev <buffer> iff if () {<left><left><left>
- groups
  * group related autocmds into named groups
  * if autocmds are not placed in groups, they are duplicated every time
    the file that defines them (typically .vimrc) is source
    - makes executing them slower because all the duplicates
      get executed when a command is run
  * syntax:
    augroup [name]
      autocmd! " removes all autocommands previously in this group
      [autocommands]
    augroup end
  * example: source .vimrc every time it is saved
    augroup vimrc
      autocmd!
      autocmd BufWritePost .vimrc source $MYVIMRC
    augroup end
    - see VimResized example in your .vimrc
- events
  * :help autocmd-events
  * examples
    - BufRead(Pre|Post)
    - BufWrite(Pre|Post)
    - FileRead(Pre|Post)
    - FileType - when a filetype is set for a file
    - Insert(Enter|Leave)
    - Tab(Enter|Leave)
    - VimResized
    - Win(Enter|Leave)
- warning
  * sourcing .vimrc runs autocommands again, duplicating listeners
  * this is why most autocommands should be in groups
    that start with autocmd!

Bash
- To use vi keystrokes for bash command-line editing,
  set -o vi

Buffers
  ctrl-^               - switch to previous buffer
  :bp[rev]             - switch to previous buffer (you mapped <- to this)
  :bn[ext]             - switch to next buffer (you mapped -> to this)
  ctrl-^               - toggle to previous buffer
  :ls                  - list buffers (same as :buffers)
    buffer characteristic indicators include:
    % - buffer in current window
    # - alternate buffer for ":e #" and CTRL-^
    a - active buffer: it is loaded and visible
    h - hidden buffer: loaded, but not displayed in a window
    = - readonly buffer
    + - modified buffer
    x - buffer with read errors
  :b{buffer-number} - to switch to the indicated buffer
  :b {name-fragment} - to switch to the indicated buffer
    Tab completion can be used to cycle through all the buffers
    whose file path contains the text.
    Very cool!
  :bd[{buffer-number}] - to delete the indicated buffer
    If buffer-number is omitted, currently displyed buffer is deleted.
    Multiple buffer numbers can be specified, separated by spaces.
    This really just marks the buffer as unlisted.
    To see it, use :ls!.
  :bufdo bd - to delete all buffers
  :bw[{buffer-number}] - to wipeout the indicated buffer
    Unlike :bd, this completely deletes the buffer.

BufExplorer plugin
- similar to NERD_Tree, but for buffers instead of files
- see https://github.com/vim-scripts/bufexplorer.zip
- works with MacVim
- to install using Pathogen
  * cd .vim/bundle
  * git clone https://github.com/vim-scripts/bufexplorer.zip.git
    - or add as a submodule
  * restart Vim
- using
  * \be for open in current pane
  * \bs for horizontal split open
  * \bv for vertical split open
  * use j and k keys to move up and down to highlight a buffer
  * press return to open highlighted buffer
  * press F1 for help on other command keys used in this mode

Change (delete and enter insert mode)
  c  - change selection (deletes selected text)
  cc - change line (deletes current line)
  cw - change word (deletes word under cursor)
  c$ - change from cursor to end of line
  C  - same as c$
  s  - substitute characters (can precede with # of characters)
       and enter insert mode
  c/{text}Enter - change all characters from cursor to given text
  cgn - change selected text and
        enable use of dot to change subsequent occurrences
        * press n to jump to next occurence
          - can press repeatedly to skip some occurrences
        * press . to make the same change again
          - press this before pressing n to both
            jump to the next occurrence and change it


Change Case
- to change the case of the letter under the cursor, press ~
- to change the case of multiple characters,
  * to lowercase, gu{motion}
  * to uppercase, gU{motion}
  * ex. to uppercase word under cursor, gUiw
  * ex. to uppercase the next three words, 3gUw

Code Indenting
- add "filetype indent plugin on" in .vimrc to use filetype-dependent
  settings specified in files in the .vim/ftplugin directory
- settings in these files override those in your .vimrc
- for example, create .vim/ftplugin/java.vim containing
  set shiftwidth=4
  set tabstop=4
- options
  :set cindent        - for indenting source code
                        (requires "filetype indent on" in .vimrc)
  :set shiftwidth={#} - sets number of spaces used for indentation
  :set sw={#}         - same as above
  :set cinoptions=(1s - to indent continuation lines with an open paren
                        by one shiftwidth
                        (see :help cinoptions-values for more options
                         and a list of the defaults)
- commands
  ==                  - fixes indentation of current line or selected lines
  =                   - fixes indentation of selected lines
  >                   - indents selected lines
  >>                  - indents current line
  <                   - outdents selected lines
  <<                  - outdents current line
  gg=G                - goes to first line then reindents entire file

Color Schemes
- language-specific syntax highlighting definition files are in
  ~/.vim/syntax (ex. javascript.vim)
  * to reload changes to these files, can enter :source .vimrc
- can use Solarized color theme
  * but using this in iTerm changes the values of the standard colors!
  * try setting iTerm color presets to "Light Background" or "Dark Background"
    instead of a Solarized variant
- in GVim, see Syntax...Highlight Test
- add "syntax on" in .vimrc to enable colors
- :hi - to see all the current syntax colors
- to see the syntax groups that are applied to the text under the cursor
  * :echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
  * you mapped this to <leader>sg
- standard color names (case insensitive)
  * white, black, brown (looks like orange),
  * gray, red, green, yellow, blue, magenta, cyan
    (above can be preceded by "light" or "dark")
- cterm color codes
  * see vim-cterm-colors.png in this directory
- save color scheme .vim files in
    ~/.vim/colors for Unix
    $VIM_HOME/vimfiles/colors for Windows
  * also see schemes in /usr/share/vim/vim72/colors
- find valid color names in /usr/X11R6/lib/X11/rgb.txt.
- to change to a named color scheme defined in a .vim file
  stored in the appropriate colors directory,
  :colo[rscheme] {name} - use color scheme from file {name}.vim
  For example, :colo evening
- to cycle through all the installed color schemes,
  enter ":colorscheme " and then continually press Tab.
  To see all the installed color schemes,
  enter ":colo " and press ctrl-d.
- font styles
    bold, italic, underline, reverse, standout, NONE (to reset)
- font names
  * default is FixedSys
  * set with font attribute of highlight command
    - ex. hi Comment font=Courier
- examples of changing individual colors
  :hi Normal guifg=black guibg=white
  :hi comment ctermfg=blue - when using a terminal window
  :hi comment guifg=blue - when using a GUI
  :hi Search ctermfg=white ctermbg=red
  :hi LineNr ctermfg=0 - to display line numbers in gray
- can also set ctermbg and guibg
- recommendations
  hi Normal font=Fixedsys ctermfg=black ctermbg=white guifg=black guibg=white
  hi Comment ctermfg=darkgray guifg=darkgray
  hi Constant ctermfg=darkgreen guifg=darkgreen
  hi Define ctermfg=magenta guifg=magenta
  hi Fold ctermfg=0 ctermbg=1 " gray on red
  hi Identifier ctermfg=blue guifg=blue
  hi IncSearch ctermfg=white ctermbg=gray
  hi LineNr ctermfg=gray guifg=gray
  hi Search cterm=reverse ctermfg=3 ctermbg=1 \
            gui=reverse guifg=yellow guibg=red
  hi Special ctermfg=5 guifg=orange
  hi Statement ctermfg=blue guifg=blue
  hi Todo ctermfg=3 - to display TODO in comments in yellow
  hi Type ctermfg=red guifg=red

Comments in .vimrc file
- precede with " character and extends to end of line

Compiling code
- see :help quickfix.txt

Completion of commands after :
  tab - to complete a command name, file path, ...
  - to cycle through possible matches, keep pressing tab
  ctrl-d - display list of all possible matches

Completion in insert mode
  ctrl-n or down arrow - cycle to next matching word and substitute it
  ctrl-p or up arrow - cycle to previous matching word and substitute it
  - these consider all words in all open buffers
  - to select word under cursor in list,
    just continue typing (ex. space)
  - can also use up and down arrow keys to navigate list,
    but must press return key to substitute a word
  - can enable this with tab key using the following line,
    but this conflicts with the snipmate plugin, so don't do it!
    imap <TAB> <C-n>
  - to allow filtering of word list while typing,
    begin a particular form of completion (ex. ctrl-x ctrl-k),
    immediately press ctrl-p, then type
  - to cancel completion without selecting a word, ctrl-e
  - to only consider words in the current buffer, ctrl-x ctrl-n
  - for dictionary lookup, ctrl-x ctrl-k
    * you mapped <leader>d to this
    * configure location of dictionary file in .vimrc
      with set dictionary={file-path}
  - for thesaurus lookup, ctrl-x ctrl-t
    * configure location of thesaurus file in .vimrc
      with set thesaurus={file-path}
  - for filename completion of files in current working directory,
    ctrl-x ctrl-f
    * it's not necessary to type anything before invoking this
    * see "Working Directory" section for commands to see and change it
    * use ctrl-n and ctrl-p to navigate the list
    * if on a directory, press ctrl-x ctrl-f again to navigate into it
  - also see section on Omni-completion

Copy (yank)
  y  - yank (copy) selection
  yw - yank (copy) word (cursor position to end of work)
  yiw - yank (copy) inner word (under cursor)
  yy - yank (copy) current line
  Y  - same as yy

Counts
- most commands can be preceded by a number that indicates
  how many times the command should be executed

CtrlP plugin
- fuzzy search for file paths, filenames, and
  most recently used (mru) files
- similar to Command-T plugin, but faster
  and doesn't depend on Ruby support
- :h ctrlp-commands
- :h ctrlp-mappings
- you mapped ctrl-p to this
  * let g:ctrlp_map = '<c-p>'
  * let g:ctrlp_cmd = 'CtrlP .' " note dot to start in current directory
- first time ctrl-p is pressed, will index files (takes a few seconds)
- after pressing ctrl-p
  * press ctrl-f to cycle through modes (files, buffers, mru files)
  * press ctrl-d to toggle between full path and filename-only search
    - stays in selected mode until you change it
  * press ctrl-r to toggle between string and regex mode
  * type characters to match in file paths or names depending on mode
  * use ctrl-j and ctrl-k to navigate list
  * to open file under cursor
    - press enter to open in current window
    - press ctrl-v to open in new vertical split
    - press ctrl-s to open in new horizontal split
  * to close without selecting a file, press esc or ctrl-c

Delete
  d  - delete selection
  dd - delete current line
  de - delete to end word under cursor
  diw - delete word under cursor
  dw - delete to beginning of next word or
       whitespace from cursor to next non-whitespace
  d$ - delete from cursor to end of line
  D  - same as d$
  x  - delete character under cursor or visual selection
  d/{text}Enter - delete all characters from cursor to given text
  To delete without affecting the clipboard, precede command with "_
  which sends the deleted content to the "blackhole" register.
  For example, "_dd.

Diffs
  There are many ways to use this.  One way is as follows.
  - open first file
  - ":sp" to split the window
  - open second file in second window
  - ":diffthis" in both buffers
  - "]c" to move to next difference
  - "[c" to move to previous difference
  - ":set nodiff" to turn off diff in the current buffer
  - for diffs of Git versions, use Gdiff command in Fugitve plugin
    or git-gutter plugin

EasyMotion
- makes it faster to jump to a spot in a file
- for detailed help, :help easymotion.txt
- all keyboard shortcuts start with <leader><leader>
- to jump forward to a given word
  * enter <leader><leader>w
  * the first letter of the next 26 words are temporarily replaced by
    the letters a-z in red and the first two letters of the remaining
    words are replaced by other character combinations in yellow
  * press the letter or letter combination to jump to
- word commands
  * w | beginning of word forward (you changed to go in both directions)
  * W | beginning of WORD forward
  * b | beginning of word backward
  * B | beginning of WORD backward
  * e | end of word forward
  * E | end of WORD forward
  * ge | end of word backward
  * gE | end of WORD backward
- line commands
  * j | line forward
  * k | line backward
- character commands
  * s | find (search) {char} forward and backward
  * f{char} | find {char} forward
  * F{char} | find {char} backward
  * t{char} | till before {char} forward
  * T{char} | till after {char} backward

Echo
- :ec[ho] expr ...
  * starts a new line and outputs each expression with a space
    between each in the message area below the status line
  * expressions must evaluate to strings
  * strings can contain \n for newlines to output multiple lines
- :echon expr ...
  * similar to echo, but doesn’t add a space between the expressions
- :echom[sg] expr ...
  * similar to echo, but also saves output in message history
    - see "Message History" section
  * useful for debugging Vimscript
- :echoe[rr] expr ...
  * same as echomsg, but rendered as an error message

Emmet
- HTML and CSS dynamic snippets
- see Emmeet/EmmetNotes.md

Filtering Lines
- to pass a range of lines to a shell command,
  select the lines using V, type ! and then a shell command
- selected lines will be replaced by the command output
- for example, to sort imports at the top of a Java source file,
  select them and enter "!sort"
  * requires shell sort command (not in Windows, but in Cygwin)

FixMyJs
- runs "eslint --fix" on current buffer without saving it
- you configured <leader>f to run this

Folding
- commands to control folding include
  zfap - create a new fold
  zo - open fold under cursor
  zc - close fold under cursor
  za - toggles fold under cursor (alternative to zo and zc)
  zO, zC, and zA - recursive versions of above
  zf - fold selected lines
  zj - move to next fold
  zk - move to previous fold
  zr - reduce/open all folds one level deep
  zR - recursive version of zr (all levels)
  zm - fold more; close all folds
  zM - recursive version of zm (all levels)
- to configure folding of javadoc-style comments, add this to .vimrc.
  autocmd FileType java :set fmr=/**,*/ fdm=marker fdc=1
- can use triple braces in comments to manually define fold regions
  * see your .vimrc file
- to cause files of certain types to start with all folds closed
  when a file is opened, see :help foldlevel and :help foldlevelstart
  * value is negative (not used; default), 0 (all folds closed),
    1 (some folds closed), or 99 (no folds closed)
- JavaScript folding is configured in .vim/ftplugins/javascript.vim

Fonts
- example
  :set guifont=Monaco:h14

Fugitive
- for issuing Git commands from inside Vim
- :help fugitive
- all commands start with "G"
- can run any Git command with ":Git {command}
- provides auto-completion of repository paths
- % refers to the current file
  * ex. :Git add % and :Git mv % {new-path}
- many shorthand commands for common operations
  that also interact with the current buffer
  * :Git checkout % to revert current file
    - can be performed with :Gread
  * :Git add % to stage current file
    - can be performed with :Gwrite
  * :Git mv % {new-path} to move or rename current file
    - can be performed with :Gmove {new-path}
  * :Git rm % to remove current file
    - can be performed with :Gremove
    - only stages the file to be deleted; doesn't commit
    - does not delete the buffer
  * :Git commit -av to commit modified files
    - can be performed with :Gcommit -av
      and commit comments can be entered in a split window
  * :Git blame to see who last modified each line in a file
    - can be performed with :Gblame
  * :Git status to see files that have been added or modified
    - can be performed with :Gstatus
      * use ctrl-n and ctrl-p to move to next and previous file
      * to stage or unstage file on current line, press "-"
      * to view file on current line, press enter key
  * :Git diff to see differences in current file
    and the last committed version
    - can be performed with :Gdiff
    - add a SHA to see differences with a specific revision
    - to exit, close the readonly buffer marked "RO" with :bd
      or use :only in the other buffer
    - committed version is on left and uncommitted version is on right
    - added lines are green
    - removed lines are red
    - when run on a file containing merge conflict markers
      * a three-way merge with three vertical splits is presented
      * the target file (2) is on the left
      * the merge file (3) is on the right
      * the file with conflict markers (1) is in the center
      * position cursor on a conflict in center split
      * to keep changes from target (left) enter :diffget //2 | diffup
      * to keep changes from merge (right) enter :diffget //3 | diffup
      * the diffup command in the previous two lines
        updates diff highlighting of the buffers
        and can be run separately with :diffupdate
      * to jump to next changeset, press ]c (same as in Diffs section)
      * to jump to previous changeset, press [c (same as in Diffs section)
      * when finished resolving conflicts
        - make sure cursor is in center window
        - enter ":only" to close the target and merge windows
        - :Gcommit -av
- relative paths passed to commands
  * paths that start with / are relative to the repository root directory
  * other paths are relative to the current file directory

git-gutter
- shows diff symbols in gutter while editing any file that is in a git repo
- ~ means changed, + means added, _ means deleted
- to toggle display of this gutter, :GitGutterToggle
- see https://github.com/airblade/vim-gitgutter

global
- :[range]g[lobal]/{pattern}/[cmd]
  executes cmd on all lines in [range] that match {pattern}
  * ex. :g/^$/d deletes all empty lines
  * ex. :g/^\s*$/d deletes all lines that are empty or only contain whitespace
  * if [range] is omitted, all lines in file are considered

grep (also see vimgrep)
- searches files in and below current directory (faster than vimgrep)
- uses an external shell command
  * grep by default which doesn't include column numbers in output
    so cursor can't move to the column of the match
  * can configure to use another command like ack or "The Silver Searcher"
    - see "Silver Searcher" section
- :gr[ep] [options] {pattern} {files}
  * -i option makes case-insensitive
  * pattern can be a regex surrounded by /'s
  * files can use * wildcard to match zero or more characters
  * files can use ** to recursively search subdirectories
  * populates quickfix list
    - use :lgr[ep] to populate location list instead
    - can use "unimpaired" plugin key mappings to navigate
  * ex. gr parseInt **/*.js

HTML Output
- to write a source file out as HTML,
  including color-coded syntax highlighting,
  enter :TOhtml.
  * creates a buffer with the name of the file and ".html" at the end
  * need to write it with :w

Installing Plugins
- see "Native Package Loading"
- to see list of plugins that were successfully installed,
  :scriptnames
- see "Submodules" section in GitNotes.txt
  * describes how to add Vim plugin Git repos as submodules of your Git repo
  * example
    - cd ~/MyUnixEnv
    - git submodule add https://github.com/wincent/Command-T.git .vim/bundle/command-t

Key Mapping
- to show current key mappings,
  * map - shows all mappings?
  * nmap - shows normal mode mappings
  * imap - shows insert mode mappings
  * these do not show builtin mappings
    - probably just have to use help command
      (see email from Bill Odom on 5/31/14)
- to define a key
  * "nore" variants avoid recursive mappings where
    key mappings in the command are interpreted again
    - it is recommended to use these variants
      unless recursive evaluation is explicitly needed
  * for normal mode, nmap or nnoremap
    - nnoremap {key} {command}
  * for insert mode, imap or inoremap
    - inoremap {key} {command}
    - in insert mode, <c-o> escapes to normal mode for one command
      and then switches back to insert mode
  * for visual mode, vmap or vnoremap
    - vnoremap {key} {command}
  * for normal and visual mode, map or noremap
    - nnoremap {key} {command}
  * noremap versions do not take existing mappings into account
    when running the command
    - recommended over non-noremap versions
- to show a single key definition,
  omit {command} from the commands above that define them
- special keys are specified inside angle brackets
  - "c-" stands for ctrl key
  - examples: <cr>, <esc>, <space>, <c-d>
  - can use these inside command string
- can include special unicode characters in command string
  with &#9999; where 9999 is the decimal unicode value
- "ex" commands start with :
  - ex. map <F5> :CoffeeRun
- to avoid displaying the command when the key is pressed,
  preceded the key with <silent>
  * ex. nnoremap v <silent> :vsplit<cr>
- to define a mapping that is only active buffers of a specific file type
  * define mapping in .vim/ftplugin/{file-type}.vim like this:
    nnoremap <buffer> v :vsplit<cr>
- can use both <buffer> and <silent>, but must be in that order
- in .vimrc, can't put comments at end of a mapping
- to call a function defined in script scope (with s:)
  from a key mapping
  nnoremap {key} :call <SID>{fn-name}()
  * must define mapping in the same file that defines the function
- to map <c-s> or <c-q>, disable start/stop output control
  in .bashrc with "stty -ixon"
- to undefine a key
  * for normal mode, nunmap {key}
  * for insert mode, iunmap {key}
  * for visual mode, vunmap {key}

Keyboard Macros
  q{letter} - to start recording macro {letter}
  q         - to stop recording
  @{letter} - to call macro {letter}
  @@        - to call the last executed macro again
- macros are saved across editing sessions
- to paste the content of a macro at the current cursor position
  * enter i ctrl-r ctrl-r {macro-key}

Leader Key
- first key pressed to invoke many plugin commands
  and typically your own custom key mappings
- defaults to \
  * to see current value, :let mapleader
  * to change to comma, add this to .vimrc
    let mapleader = ","
- local leader
  * a prefix for mappings that only take effect
    for certain types of files,
    like JavaScript or HTML files
    * often used in key mappings of filetype plugins
  * defaults to \
    - to change to backslash, add this to .vimrc
      let maplocalleader = "\\"
      or
      let maplocalleader = '\'

Location List (also see Quickfix List)
- like quickfix list, but associated with the current window
- each window can have its own
- uses same commands, but prefixed with "l" instead of "c"

Marks
- allow marking locations and quickly jumping to them
- named similarly to registers, but not related to them
- to set
  * to current line/column location, m{letter}
  * to first non-blank character in current line, :ma[rk] {letter}
  * letter can be
    - lowercase - valid within the current buffer for session
    - uppercase - valid between buffers for session
- to visit
  * specific line/location marked, `{letter}
  * first non-blank character in line containing mark, '{letter}
  * last location in last file edited, `0 or '0
    - for previous files, use numbers 1 to 9
  * to return to the previous location,
    jump to the mark named ' with ''
    - can use repeatedly to toggle the location back and forth
- to list current marks in the current buffer, :marks
- to delete marks in current buffer
  * all, :delm[arks]!
  * specific, :delm[arks] {marks}

Matchit
- a Vim macro that enables jumping between start and end HTML/XML tags
  by extending the functionality of the % key
- press the % key when the cursor is on tag
  to jump to the corresponding tag
- to enable, add this to .vimrc
  runtime macros/matchit.vim

Message History
- :mes[sages] to see content of message history
- will see "Press ENTER or type command to continue" at bottom
  * can also press space
  * press g< to see last page of previous command output
- can’t clear message history

Modes
- normal - for navigating and manipulating text
- insert - for inserting text; many ways to enter (a, i, A, I, C, s, ...)
  * keys to enter insert mode
    a - enter insert mode after cursor (append)
    A - enter insert mode at end of current line (append)
    i - enter insert mode before cursor
    I - enter insert mode at start of current line
    o - "open" new line after current one and enter insert mode
    O - "open" new line before current one and enter insert mode
- replace - for replacing characters under cursor (overstrike)
  * press R to enter replace mode
  * can also replace an individual character without entering replace mode
    by pressing r and a replacement character
- visual - for selecting text and manipulating it
  * character (v), line (V), and block (ctrl-v; rectangular selection) submodes
  * see "Select in Visual Mode" section
  * visual block mode example
    - move to block upper-left
    - press ctrl-v
    - move to block lower-right
    - press c
    - enter replacement text
    - press esc
  * to select the content of a tag or the start, end, and content
    place the cursor on either tag or in the content
    and press vat to include the tags
    or vit to only select the content
    - to expand the selection outward farther, repeatedly press at or it
      * ex. vatatat or v3at
    - once a tag is select, press o to jump between the start and end tags
      or press % if the matchit macro is enabled
- select - similar to visual, but Windows-like
  * not sure when this would be desirable
- command-line - for entering one ex command (:)
  * returns to normal mode after running one command or pressing esc
- ex - for entering multiple ex commands (Q)
  * like command-line mode, but doesn’t return to normal mode
    after running a single command
  * to return to normal mode, enter vi[sual]
- operator pending
  * when an operator character has been pressed and
    Vim is waiting for a motion command to be entered
- to exit current mode and return to normal mode,
  press esc or ctrl-[ (except in ex mode)

Moving Around
  gg       - beginning of file
  G        - end of file
  ctrl-f   - forward one page
  ctrl-b   - backward one page
  ctrl-d   - forward half page
  ctrl-u   - backward half page
  H        - highest (top) line in window; doesn't scroll
  L        - lowest (bottom) in window; doesn't scroll
  M        - middle line in window; doesn't scroll
  zt       - move current line to top of window (z Enter also)
  zb       - move current line to bottom of window
  zz       - move current line to center of window
  {        - backward one paragraph (to previous blank line in source code)
  }        - forward one paragraph (to next blank line in source code)
  (        - backward one sentence
  )        - forward one sentence
  0        - beginning of line
  ^        - first non-blank char in line
  $        - end of line
  e        - end of next word
  w        - forward to beginning of next word
  b        - backward to beginning of previous word
  {count}G - line number {count}
  arrows   - one char or line at a time;
             must hold shift key when in visual mode if "behave mswin"
  h        - move left one char
  l        - move right one char
  j        - move down one line
  k        - move up one line
  f{char}  - forward to next occurrence of {char} on same line
           - repeat forward with ; and backward with ,
  F{char}  - backward to previous occurrence of {char} on same line
  t{char}  - forward to just before next occurrence of {char}
  T{char}  - backward to just before previous occurrence of {char}

Native Package Loading
- added in Vim8
- initial setup
  * create the directory ~/.vim/pack/plugins
  * create the subdirectories opt and start
    - opt is for plugins that will be manually loaded when needed
      by entering ":packadd {packagename}"
    - start is for plugins that will be automatically loaded
      when Vim is started (most will go here)
    - consider making this submodules of the Git repo
      that holds your Vim configuration
- installing a new plugin
  * cd ~/.vim/pack/plugins/start
  * clone the git repo for the plugin
- for more information, see https://shapeshed.com/vim-packages/

NERD_Tree plugin
- tried it, but like using built-in netrw better

NERD Commenter
- <leader>ci toggles commenting of current line
- <leader>cc comments lines selected in visual mode with single line comments
- <leader>cm comments lines selected in visual mode with one multiline comment
- <leader>cu uncomments lines selected in visual mode

Netrw (network-oriented reading, writing, and browsing)
  :E[xplore] [start-path]  - open explorer in current window
  :S[explore] [start-path] - open explorer in split window
  Once in explorer window,
  ?         - toggles display of help on keys to use in explorer
  Enter key - opens file/directory under cursor in explorer
  o         - opens file/directory in new window, leaving explorer displayed
  -         - goes up to parent directory
  i         - toggles display of file sizes, modification dates,
              and the layout (including tree view!)
  D         - deletes file
  R         - renames file

Numbers
- ctrl-a increments number under cursor
- ctrl-x decrements number under cursor

Omni-completion
- similar to intellisense in some IDEs
- Vim ships with support for several languages
  including HTML, CSS, JavaScript, PHP, Ruby, and SQL
- to get a list of possible completions, press ctrl-x ctrl-o
- like other kinds of completion,
  navigate the list with ctrl-n and ctrl-p
- when the desired completion is under the cursor, just continue typing
- in HTML, can use after an element name to see possible attribute
- in CSS, can use after a property name to see possible values

Opening, Saving and Quiting
  :e {name} - edit file {name}; file is created if it doesn't exist
              Can use FTP to edit remote files.  For example,
              :e ftp://www.ociweb.com/index.html
              Can use scp to edit remote files.  For example,
              :e scp://volkmanm@xi/BAE/JSFTacan/
                 branches/dev-branch/test/vector/baevector.h
              (will prompt for username/password;
               didn't seem to write changes back!)
  :e        - reload current file (useful if modified outside vim)
  :r {name} - insert content of file {name} after cursor
  :w        - write (save);
              you mapped <c-s> to do this in both normal and insert modes
              (search for -ixon in this document)
  :q        - quit current window unless changed
  :q!       - quit current window and discard changes
  :qall     - quit all windows
  :wq       - write and quit
  :x        - same as :wq, but only writes if changed
  ZZ        - same as :x

Options
- one way to view and set options is to enter ":options"
  * opens a window that displays all the options,
    provides a description of each, and shows ther current values
- boolean options
  * to enable, :set {name}
  * to disable, :set no{name}
  * to toggle, :set {name}!
  * to determine if enabled, :set {name}?
    - outputs {name} or no{name}
- value options
  * to set, :set {name}={value}
  * spaces around = are not allowed
  * to see current value, :set {name}jj?
- can set multiple options with one :set command
- to work with values specific to current buffer
  * use :setlocal instead of :set
    - these take precedence over global options
    - can't be used with all options
- popular options
  * nu[mber] - boolean; adds line numbers
    - defaults to off
    - relativenumber or rnu shows line numbers relative to line with cursor
      to help determine count for vertical motion commands
  * numberwidth or nuw - value is width of line number column
    - defaults to 4; minimum is 1; maximum is 10
  * wrap - boolean; wraps display of lines longer than window width
    - doesn't add newlines to file
    - defaults to on
  * shiftround - boolean; rounds indent to multiple of shiftwidth
    - used by > and < commands
    - defaults to off

Paste
  p  - paste after cursor
  P  - paste before cursor
  ]p - paste with indentation adjustment (for source code)
  * To paste text from another application that was copied
    to the system clipboard and retain its indentation
    - :set paste!
    - cmd-v (without being in insert mode)
    - :set paste!

Pathogen
- a way to install Vim plugins
- I have switched to using "Native Package Loading" described above
- add these lines to .vimrc
  call pathogen#infect()
  call pathogen#helptags() " generates help documentation for plugins
- create a directory under the ".vim" directory named "bundle"
- use "git clone {url}" in that directory to install plugins
- to use the plugin, either restart vim or
  :source ~/.vim/bundle/{plugin-name}/plugin/{plugin-name}/vim
- see https://github.com/tpope/vim-pathogen
- also consider Vundle

Python
- some plugins require Vim to be built with Python support
  * Cygwin Vim doesn't have this by default
- steps to build
  install Mercurial if not already installed ("brew install hg" on Mac OS X)
  hg clone https://vim.googlecode.com/hg/ vim
  cd vim/src
  ./configure --enable-multibyte --without-x --enable-gui=no --enable-pythoninterp=yes
  make
  make install
  ln -sf /usr/local/bin/vim.exe /usr/bin/vim

Quickfix List (also see Location List)
- list of records containing filename, line number, and optional column number
- typically produced by a compiler or linter
  * ex. :!jshint
  * automatically updated as issues are fixed (at least with jshint)
- many tools that populate the quickfix list do not open it
  and automatically jump to location of first record
- to skip to the next or previous record location, :cn[ext] or :cp[revious]
  * can repeat last ex command with @:
  * can repeat last macro with @@
  * so :cn @: @@ @@ @@ visits next five
- to skip to the first or last record location, :cfir[st] or :cla[st]
- when list contains references to more than one file,
  it can be useful to skip to those for the next or previous file
  * to skip to first record in next file, :cnfile
  * to skip to last record in previous file, :cnprev
- to view all records, :cope[n]
- you configured <leader>q to toggle viewing quickfix list
- to jump to record reference under cursor, press <cr>
- to close quickfix list, :ccl[ose]
- there is only one current quickfix list,
  but others are saved in a stack
  * to switch to the previous one, :colder
  * to switch to the newer one, :cnewer
- recommended plugin: unimpaired (see separate section)

Reflow text in a paragraph
- position cursor anywhere in a paragraph and
  enter gqap (leaves cursor on first line of next paragraph)
  or gqip (leaves cursor on blank line after paragraph)
  * seems to default to a max line width of 80 characters
- in code this puts all lines in a function on one line
  if it fits within line length

Registers
- like named clipboards
- hold text that can be pasted
- to place text in a specific register,
  precede yank or delete command with "{register-name}
  where register name is a-z (note the double-quote!)
  * if an uppercase register name is used, the text is appended to the
    text already in the register with the corresponding lowercase name
- when yank or delete command is used without a register name,
  the "unnamed register" is used
- to paste text from a register
  * in normal mode, "{register-name}p
  * in insert mode, ctrl-r{register-name}
- register 0 holds the text from the last yank
- registers 1 to 9 hold the most recent deletes
- register % holds the current filename
- register # holds the previous filename that was being edited
- register / holds the last search text
- register - holds the last "small" delete text (less than a line)
- register . holds the last inserted text
- register : holds the last ex command entered
- :reg to see contents of all registers
- :reg {names} to see contents of all registers
- register contents are stored in ~/.viminfo
  and restored when Vim is restarted

Regular expressions
- slightly different than other regular expressions
- see "very magic" regex parsing mode
- quantifiers
  * \= means zero or one of preceding
  * * means zero or more of preceding
  * \+ means one or more of preceding
- for more, see http://vimregex.com and
  http://vim.wikia.com/wiki/Search_across_multiple_lines

Reverse order of lines
- all lines in file
  :g/.*/m0 - for all lines, move it to line zero
  * can also do this from bash with
    tac {filename} > {new-filename}
    - tac is the reverse of cat
- selected lines
  * select lines and enter !tac

Ruby Support
- some plugins require Vim to be built with Ruby support
  * describe how to do this
- cd ~/.vim/bundle
- git clone https://github.com/vim-ruby/vim-ruby.git
- add the following to .vimrc
  set nocompatible      " We're running Vim, not Vi! (default setting)
  syntax on             " Enable syntax highlighting
  filetype on           " Enable filetype detection
  filetype indent on    " Enable filetype-specific indenting
  filetype plugin on    " Enable filetype-specific plugins
- the previous three lines can be written as
  filetype indent plugin on

Search and Replace
  :set incsearch - move to search matches while typing search string
  :set hlsearch - highlight all matches after pressing Enter
  :set ic - case-insensitive searches
  :set noic - case-sensitive searches
  /{pattern} - search forward for next occurrence, cursor placed at match start
  /\c{pattern} - same as previous, but case-insensitive
  /{pattern}/e - same as previous, but cursor placed at match end
  ?{pattern} - search backward for previous occurence
  * - search forward for next occurence of word under cursor
  # - search backward for previous occurence of word under cursor
  :noh[lsearch] - turn off highlighting of matches from last search
  n - repeat last search
  N - repeat last search in opposite direction (use ctrl-p in insert mode?)
  * - search forward for next occurrence of word under cursor
  # - search backward for next occurrence of word under cursor
  :%s/{pattern}/{string} - replace first occurrence of {pattern} with {string}
  * to remove trailing whitespace from all lines, %s/\s\+$//
  * to add space before open braces, %s/\(\w\){/\1 {/
    - capture groups are surrounded by \( \)
    - backreferences to capture groups are \1, \2, ...
  :%s/{pattern}/{string}/g - all occurrences
  :%s/{pattern}/{string}/gc - all occurences with confirmation prompts
  :%s/\t/  /g - replace all tabs with two spaces
  :set ff=unix - removes Windows carriage returns from all lines
  :%s/ctrl-vctrl-m$//g - also removes Windows carriage returns from all lines
                         and is sometimes needed instead of the previous
  :%s/ctrl-vctrl-m/ctrl-vctrl-m/g - replaces Windows carriage with Unix ones
  :.,$s/{pattern}/{string}/g - all occurrences from the cursor to end of file

Select in visual mode
- highlights selected text
  v - begin visual selection in char mode;
      now move cursor to end of selection;
      includes char under cursor;
  V - begin visual selection in line mode
  ctrl-v - begin visual selection in block mode
  o - changes end of selection being moved
- after selecting a region, can use commands like
  yank (y), delete (d), and paste (p)
- substitutions in visual mode only affect selected lines
  :'<,'>s/old/new/
- see vim-expand-region plugin below

Shell commands
- see Conque at http://code.google.com/p/conque/
- not really useful when running Vim in tmux
- may need to install newer version of python (works with 3.2.1)
- download and unzip into .vim/bundle directory
- to run a bash shell in current Vim buffer, :ConqueTerm bash
- other examples
  :ConqueTermSplit mysql -h localhost -u joe -p sock_collection
  :ConqueTermTab bash
  :ConqueTermVSplit bash
- when running Vim from a terminal window,
  can press ctrl-z to put Vim in the background
  and enter fg to return to Vim in the foreground

Silver Searcher, The
- to install
  * for Cygwin-specific steps, see https://gist.github.com/k-takata/5124445
    - copy the following file to /usr/local/bin:
      /usr/i686-pc-mingw32/sys-root/mingw/bin/pthreadGC2.dll
  * git clone https://github.com/ggreer/the_silver_searcher.git
  * cd the_silver_searcher/
  * ./build.sh
  * strip ag
  * make install (copies ag.exe to /usr/local/bin)
- to use from shell, outside of Vim
  * ag search-term file-path
    - search-term can be a string or regular expression surrounded by /'s
    - file-path can contain ** to recursively search subdiretories
      and * for wildcard
- to configure to be used by Vim commands grep and lgrep, and ctrlp plugin
  add the following to .vimrc
  if executable('ag')
    " Use ag instead of grep.
    set grepprg=ag\ --nogroup\ --nocolor\ --column
    set grepformat=%f:%l:%c:\ %m

    " Use ag in CtrlP for listing files.
    " It is lightning fast and respects .gitignore.
    let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

    " ag is fast enough that CtrlP doesn't need to cache.
    let g:ctrlp_use_caching = 0
  endif

Slime and Screen
- to install vim-slime
  * install Pathogen if not already done
  * cd ~/.vim/bundle
  * git clone git://github.com/jpalardy/vim-slime.git
  * restart Vim?
- on a Mac, screen is already installed
- to use
  * open a Terminal window
  * enter "screen -S {session-name}" to start a screen session (ex. name is node)
  * start Vim
  * open a file
  * position the cursor in a block of lines (forward and backward to a blank line)
    or select the lines to be copied
  * press ctrl-c ctrl-c to copy it to a screen session
  * the first time this is done, slime will prompt for a screen session name
    - enter a name (like "node")
    - press return a second time to accept the screen window name of "0"
  * the code will be copied to the screen session
- common use case
  * start a REPL in the screen session (such as node)
  * open a JavaScript file in Vim
  * position the cursor in a function definition
  * press ctrl-c ctrl-c to copy the function definition into the REPL
  * test the function by enter a call to it in the REPL

Snipmate
- also see "UltiSnips" section which is probably better
  * recommended by Drew Neil
  * you are using UltiSnips now instead of this!
- to install
  * cd ~/.vim/bundle
  * git clone https://github.com/tomtom/tlib_vim.git
  * git clone https://github.com/MarcWeber/vim-addon-mw-utils.git
  * git clone https://github.com/garbas/vim-snipmate.git
  * git clone https://github.com/honza/vim-snippets
  * cd vim-snipmate
- to use
  * enter a snippet name in insert mode and press tab key to expand
  * won't work if tab key has been mapped to do something else!
  * press tab to advance to next placeholder in snippet if there is one
- to modify and add snippets
  * edit the .snippet files in .vim./bundle/vim-snippets/snippets
    - for example, javascript.snippets
  * indentation in snippets must be done with tabs, not spaces
    - depending on other Vim configuration,
      tabs can expand to spaces when a snippet is used

Spell check
- to start, enter
  :setlocal spell spelllang=en_us
  * you have <leader>s mapped to toggle this in normal and insert modes
- to jump to next error, ]s
- to jump to previous error, [s
- to get list of suggested replacements, z=
  * enter number of replacement and press <cr>
    or just press <cr> to make no change
  * window of replacements hides document which seems bad
- to repeat the replacement made by z= throughout the document, :spellr
- to correct mispelled words while in insert mode, press ctrl-x s
  * get a dropdown list of suggestions rather than
    a window that hides the document which seems better
  * searches backward for a mispelled word
  * press ctrl-n and ctrl-p to select the next and previous suggestions
  * press ctrl-y to accept the selected suggestion
  * press ctrl-e to exit without changing the word
  * you mapped <leader>S to switch to insert mode and press ctrl-x s,
    but you really want it to automatically press ctrl-x s again
    after a word is corrected
  * it would also be nice to correct words going forward
    instead of backward
- to add word under cursor to list of good words, zg
  * adds to ~/.vim/spell/en.utf-8.add
- to remove word under cursor from list of good words, zw
- to add a word file for specialized jargon like computer terms,
  setlocal spellfile+=~/.vim/spell/{name}.utf-8.add
- for more see http://vimdoc.sourceforge.net/htmldoc/spell.html

Split/Join plugin
- https://github.com/AndrewRadev/splitjoin.vim
- with cursor on first line of a multiline block statement
  press gJ to join it to one line
- with cursor on a single line block statement
  press gS to split it onto multiple lines

Splits
- see "Windows" below

Status Line
- can configure contents
- spaces must be escaped with a backslash
- my preferences are:
  set statusline=%t " file name (omits path)
  set statusline+=%M " modified flag
  set statusline+=%R " read-only flag
  set statusline+=%{ALEGetStatusLine()} " Asynchronous Lint Engine
  set statusline+=%= " left/right side separator
  (right aligns all the content that follows)
  set statusline+=line\ %l " current line number
  set statusline+=\ of\ %L " total lines
  set statusline+=,\ col\ %c, " cursor line number and column
  set statusline+=\ %P " percent through file
  set laststatus=2 " always display status line
  " change status line background color based on mode
  highlight StatusLine ctermfg=red ctermbg=white
  autocmd InsertLeave * highlight StatusLine ctermfg=red ctermbg=white
  autocmd InsertEnter * highlight StatusLine ctermfg=darkgreen ctermbg=white
- %f shows the file name of the current file
- there are also plugins that give a nice status line
  * consider using vim-airline

Surround plugin
- https://github.com/tpope/vim-surround
- operates on the things (delimiters) that surround text,
  not on the text inside them
- adds, deletes, and changes surroundings (delimeters)
- delimeters can be ' " ` ( ) { } [ ]
  and HTML/XML tags (not angle brackets <>)
- in descriptions below
  * when {new} is (, {, or [, a space will be added inside them
  * when {new} is ), }, or ], no space will be added inside them
- to add surroundings to text selected in visual mode (V or v)
  * select text and press S{new}
  * ex. to surround selected text with double quotes,
    select it and press S"
  * ex. to surround selected text with a div tag,
    select it, enter S<div>
    - can also press return instead of typing closing >
  * ex. to surround selected text with a p tag that has attributes,
    select it, enter S<p id="foo" class="bar">
- to add surroundings to text specified with a text object
  ys{text-object}{new}
  * text-object selects the text to be surrounded
  * ex. to add double quotes, ysiw"
  * ex. to add double quotes around the next three words, ys3w"
  * ex. to add a div tag around the current paragraph, ysip<div>
- to change surroundings, cs{current}{new}
  * ex. to change double quotes to single quotes, cs"'
  * ex. to change double quotes to a div tag, cs"<div
  * ex. to change current surrounding tag to a div tag, cst<div
  * ex. to change current surrounding tag to braces,
    - cst{ and press return (includes a space inside { and })
    - cst} and press return (no space inside { and })
- to delete surroundings, ds{current}
  * ex. to delete double quotes, ds"
  * ex. to delete the surrounding tag, dst
    - even deletes attributes in start tag
- see https://github.com/tpope/vim-surround
- install repeat.vim plugin so the dot (.) command
  will repeat these commands in another location
- see "vat" and "vit" elsewhere in this document

Syntastic
- to see the checkers being used for the filetype of the current buffer
  * :SyntasticInfo
- to configure to only use eslint for JavaScript files
  * let g:syntastic_javascript_checkers=['eslint']
  * this is currently the best option for React JSX support
  * need to configure jsx support in .eslintrc

Tab Pages
- to open a new, empty tab, :tabe[dit]
  * can then select a file with :E
- :Te - open new tab and explore in it
- to open a new tab for a specified file, :tabe[dit] {filepath}
  * can be just the name of a file in current directory
- to open all buffers in separate tabs (up to tabpagemax), :tab ball
- to close current tab, :tabc[lose]
- to close all other tabs, :tabo[nly]
- to navigate to
  * next tab, :tabn[ext] or gt (in normal mode)
  * previous tab, :tabp[revious] or gT (in normal mode)
  * first tab, :tabf[irst]
  * last tab, :tabl[ast]
  * given tab number (starting from 1), :{number}gt
  * specific tab, click with mouse
- to have tabs always show even when there is only one window,
  add the following to _vimrc
  set showtabline=2
- to use a tab to edit a file opened using "Edit with Vim"
  from the Windows Explorer context-sensitive menu,
  add " -p" to the Windows registry under
  HKEY_LOCAL_MACHINE\SOFTWARE\Vim\Gvim\path using regedit

Tabs
- to automatically add spaces when a tab is typed,
  * set expandtab
- to insert a real tab character even when the expandtab option is set
  * ctrl-v tab
- to make it easy to see where tab characters are in a file
  * set listchars=tab:»·,trail:·
  * uses unicode characters which requires support for
    multi-byte characters to be compiled into Vim
    - seems to be the default now
    - to verify, enter "vim --version" and look for "+multi-byte"
  * renders tab characters with a right-pointing double angle
    followed by middle dots to show where the tab stop ends
  * also renders trailing spaces with middle dots

Tags
- "Ctags generates an index (or tag) file of language objects
  found in source files that allows these items to be quickly
  and easily located by a text editor or other utility."
  * such as definitions of functions, classes, and methods,
    not calls to them
- to determine whether Exhuberant Ctags is installed,
  as opposed to plain ctags
  * ctags --version
- to install Exuberant Ctags on Mac OS X, brew install ctags
  * understands 41 language syntaxes including
    C, C++, C#, HTML, Java, JavaScript, Lisp, Lua, Perl, Python,
    Ruby, shell scripts, and VimScript
    - not CSS
- to generate a "tags" file for the current directory and all subdirectories,
  enter "ctags -R"
  * to use with YouCompleteMe, "ctags -R --fields=+l" (lowercase L)
  * will get lots of warnings that say "ignoring null tag in ..."
    for JavaScript files
- helping Vim locate "tags" file
  * by default, will look in directory where Vim was started
  * can add other directories with :set tags={path-list},
    but it's easiest to just start in the correct directory
- to visit a tag in Vim, do one of the following:
  1) :ta[g] {tag}
     * visits highest priority (closest) match
  2) position cursor over tag-string and press ctrl-]
     * visits highest priority (closest) match
     * This is the default telnet escape character.
       To avoid escaping to a telnet prompt,
       include the -E option when starting telnet to disable escaping.
  3) if there might be more than one match, press g-ctrl-]
     to get a menu of matches to pick from
- maintains a history of visited tags (stack)
- to return to the previous location, press ctrl-t
- to start vim and immediately visit a given tag,
  vim -t {tag}
  * when there is more than one match,
    Vim displays all matches and allows one to be selected by number
- for more info, :help tags

Tern for Vim plugin
- provides Tern-based JavaScript editing support in Vim
- built on Node.js which isn't currently supported in Cygwin
- Tern is a code-analysis engine for JavaScript
  * see http://ternjs.net
  * commands include TernDef (ctrl-o to return to previous location),
    TernDefPreview, TernDefSplit, TernDefTab, TernDoc,
    TernDocBrowse, TernType, TernRefs, and TernRename
  * for help on Tern, :h Tern
- to install with Pathogen
  * cd .vim/bundle
  * git clone https://github.com/marijnh/tern_for_vim.git
  * install Node.js if npm command isn't available
  * cd tern_for_vim
  * npm install

Text Objects in editing commands
- operate on text as units other than individual characters
  * words, lines, sentences, paragraphs
- can be undone with the dot command
- new text objects can be defined
- text objects are not available in shell
  * to edit current shell command in Vim,
    press <esc>v, edit, and enter :wq
    to exit Vim and execute the edited command
    - can't seem to avoid executing the command on exit!
  * can simulate in shell with vi-command keymap at
    https://github.com/minos-org/bash-minos-settings/blob/master/etc.inputrc
- editing commands have two to four parts
  1) count (optional)
     can follow command, but not usually entered that way
  2) command
     d - delete (cut)
     c - change (same as d, but enters insert mode)
     y - yank (copy)
     v - visually select
     < - indent
     > - outdent
  3) motion (also see "Moving Around" section)
     - optional for some text objects to start from cursor
     a - all (includes delimiters)
     i - inner (excludes delimiters)
     t - 'til a character forward (excludes character)
     T - 'til a character backward (excludes character)
     f - find character forward (includes character)
     F - find character backward (includes character)
     /{text}<cr> - search forward for text (excludes text)
     ?{text}<cr> - search backward for text (includes text)
     {n}j - current line plus n lines after (n + 1 lines)
     {n}k - current line plus n lines before (n + 1 lines)
     - n defaults to one, so at least two lines are affected
     - ex. to change current line plus two more, c2j
     - using :set relativenumber makes these easier
       by displaying relative line numbers
  4) text object
     b - current location to beginning of word (can omit motion)
     e - current location to end of word (can omit motion)
     w - word (can omit motion)
     W - big word (delmited by whitespace) (can omit motion)
     s - sentence (requires motion)
     p - paragraph (requires motion)
     t - tag (HTML/XML) (requires motion)
     ( ) { } [ ] < > ' " ` - by delimiter
     * ( and ) mean sentence when motion is omitted
     * { and } mean paragraph when motion is omitted
     * [ ] < > ' " require motion
     * can use < and > to operate on start and end tags
     % - delimited text including delimiters
     * cursor must be on a delimiter
     * cannot specify motion
     * acts weird if a count is specified
- also see Surround plugin documented here
- examples
  * diw - delete inner word
  * caw - change all word
  * yi( - yank text inside parens
  * d} - delete to end of paragraph
  * d{ - delete to beginning of paragraph
  * d/^$<cr> - delete to next blank line
- moving cursor
  w - moves to beginning of next word
  W - moves to beginning of next big word
  b - moves to beginning of previous word
  e - moves to end of current or next word
  ( - moves to beginning of previous sentence
  ) - moves to beginning of next sentence
  { - moves to line before previous paragraph
  } - moves to line before next paragraph
  % - moves to matching delimter
  * if not on a delimeter, moves forward to next delimiter

Tools that use vi
- to cause tools that launch vi (such as cleartool edcs)
  to launch Vim instead, set VISUAL environment variable to "vim"

TypeScript
- compiler options are described at
  https://github.com/Microsoft/TypeScript/wiki/Compiler-Options
- Tsuquymoi plugin
  * https://github.com/Quramy/tsuquyomi
  * works as a client for TSServer, an editor service bundled into TypeScript
  * must have tsserver running (in TypeScript bin directory which is in PATH)
  * create tsconfig.json in project root directory
    - see https://github.com/Microsoft/TypeScript/wiki/tsconfig.json
    - also see http://json.schemastore.org/tsconfig
  * when a buffer is saved and there are errors
    - only checks for errors on save
    - lines with errors have red >> in gutter
      * more cursor to line to see error message in status area
    - errors are written to quickfix list
      * you configured <leader>q to toggle display
  * ctrl-x ctrl-o - in insert mode, show completions
  * ctrl-] - go to definition of symbol under cursor
  * ctrl-t - return to location where ctrl-] was pressed
  * ctrl-^ - show list of locations where symbol under cursor is referenced
    - navigate list with up and down arrows
      and press return to navigate to reference
  * <leader>r - renames symbol under cursor and
    all references, even in files that aren't
    currently opened in Vim (it opens them)
  * <leader>t - gives hints about symbol under cursor in status area
- syntax highlighting plugin
  * https://github.com/leafgarland/typescript-vim

UltiSnips
- to install
  * cd ~/.vim/pack/plugins/start
  * git clone https://github.com/SirVer/ultisnips
  * git clone https://github.com/honza/vim-snippets
- to configure, add these lines to .vimrc
  let g:UltiSnipsExpandTrigger="<tab>"
  let g:UltiSnipsJumpForwardTrigger="<tab>"
  let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
  nnoremap <leader>es :UltiSnipsEdit<cr>
  * previous line edits private snippet file for current filetype
  * these mappings conflict with the YouCompleteMe plugin
    - consider using <c-j> instead of <tab>
      and <c-k> instead of <s-tab>
    - to do this, add these lines to .vimrc
      let g:UltiSnipsJumpForwardTrigger="<c-j>"
      let g:UltiSnipsJumpBackwardTrigger="<c-k>"
- to use
  * enter a snippet name in insert mode and press tab key to expand
  * won't work if tab key has been mapped to do something else!
  * press tab to advance to next placeholder in snippet if there is one
- to modify and add snippets
  * default snippet files are in .vim/bundle/vim-snippets/UltiSnips
    - for example, javascript.snippets
  * my snippet files are in MyUnixEnv/.vim/UltiSnips
    - used from here; not just copies of the files
    - these add to defintions inside the UltiSnips plugin
  * to edit a private snippet file for the current filetype
    - :UltiSnipsEdit
    - if the file doesn't exist, it is created
    - these files are saved in .vim/UltiSnips/{filetype}.snippets
- snippet definitions
  * can contain shell commands in backticks
    snippet today
    Today is `date "+%B %d %Y"`
    endsnippet
  * can contain VimScript expressions in backticks with !v at beginning
  * can contain Python code in backticks with !p at beginning
    - can reference preset variables including:
      * path - path to current file
      * fn - current filename
      * t - placeholder value array (ex. t[1])
      * cur - current text in placeholder
    - example for simple JavaScript logging
      * setting snip.rv sets the return value for the current snippet
      snippet log
        console.log('`!p snip.rv = fn` ${1:function}: ${2:expression} =', $2);
      endsnippet

Unicode
- to enter accented characters, <c-k>{letter}{accent}
  * ex. for accute e, <c-k>e>
- to find the code for the character under the cursor, press ga
  * the decimal, hex and octal values will be
    displayed in the status line
- to find a unicode character by its code,
  :f/\%d{decimal-value} THIS IS WRONG!
- To substitute all occurences of a unicode character
  with another character,
  s/\%d{decimal-value}/{new-char}/g

Unimpaired Plugin
- https://github.com/tpope/vim-unimpaired
- provides 20 key mappings in four categories
- for a full list, :h unimpaired
- all take a count
- highlights
  * files
    - ]f and [f open next and previous file in
      directory of current file in alphabetical order
  * buffers
    - ]b, [b, ]B, and [B for bnext, bprevious, blast, and bfirst
  * quickfix list
    - first need to run a command that populates the quickfix list
    - ]q, [q, ]Q, and [Q for cnext, cprevious, clast, and cfirst
    - ]ctrl-q and [ctrl-q for cnfile (next file), cpfile (previous file)
      * must disable control flow in terminal with stty -ixon
  * location list
    - first need to run a command that populates the location list
    - ]l, [l, ]L, and [L for lnext, lprevious, llast, and lfirst
    - ]ctrl-l and [ctrl-l for lnfile (next file), lpfile (previous file)
  * argument list
    - if not already populated, do that with :args ...
    - ]a, [a, ]A, and [A for next, previous, last, and first
  * ctags
    - first need to navigate to a definition with ctrl-]
    - ]t, [t, ]T, and [T for tnext, tprevious, tlast, and tfirst

URL
- in normal mode with cursor over a URL,
  press gx to open URL in default web browser

vim-airline plugin
- stopped using because excess content to left of file name
  causes file name to be obscured in narrow, vertical splits
- a rewrite of the powerline plugin that is
  implemented in VimScript instead of python
  and is easier to install
- to install, git clone https://github.com/bling/vim-airline.git
- to setup Powerline fonts, see
  https://coderwall.com/p/yiot4q/setup-vim-powerline-and-iterm2-on-mac-os-x
- to enable other plugins to customize the statusline
  for specific file types (ex. mpdv),
  tell airline to exclude those file types
  * create ~/.vim/plugin/airline.vim
  * add the following line:
    let g:airline_exclude_filetypes = ['mpdv']

vimgrep (also see grep)
- searches files in and below current directory (slow!)
- doesn't use an external shell command
- :vim[grep] {pattern} {files}
  * pattern can be a regex surrounded by /'s
  * files can use * wildcard to match zero or more characters
  * files can use ** to recursively search subdirectories
  * populates quickfix list
    - use :lvim[grep] to populate location list instead
    - can use "unimpaired" plugin key mappings to navigate
  * ex. vim parseInt **/*.js
  * first matching file is opened
    - based on file type, that could trigger another command that
      creates a new quickfix list (such as jshint)
      * best way to avoid this issue is probably to use lvimgrep instead
        which populates a location list instead of the quickfix list
      * to stop jshint from running on each .js file when it is opened,
        add this to .vimrc:
        let JSHintUpdateWriteOnly = 1
      * to toggle use of jshint, run :JSHintToggle
        - only a known command after first .js file is opened
    - to return to the quickfix list created by vimgrep, :colder
    - to avoid opening first matching file,
      use vimgrep! instead of vimgrep

vim-vinegar
- enhances use of netrw plugin
- hides informational lines at top of directory listing
  * press I to toggle them on and off
- improves file sorting
- press - to go up to parent directory
- press ~ to go to home directory
- press . to populate end of : command line with file name under cursor
- press ! to populate end of : command line with file name under cursor and start with !

Vundle
- alternative to Pathogen

vim-expand-region plugin
- https://github.com/terryma/vim-expand-region
- press + to select word under cursor
- press + repeatedly to expand the selection
- press - repeatedly to shrink the selection

vim-js-arrow-function
- press <leader>af to convert a JavaScript non-arrow function to an arrow function
- press <leader>tb to toggle use of braces in an arrow function
  which is useful when changing a function from having one statement to many
  or vice versa

vim-tag-comment
- press <leader>tc to comment the entire elment (start to end tag) under the cursor
- press <leader>tu to uncomment the entire element (start to end tag) under the cursor
- press <leader>tC to comment the tag (start or end) under the cursor
- press <leader>tU to uncomment the tag (start or end) under the cursor

vipsql
- for working with Postgres inside Vim
- https://github.com/martinms/vipsql
- to install with Pathogen, clone into .vim/bundle
- to start a session
  * :VipsqlOpenSession {db-name}
  * opens a Vim buffer where all output from queries will go
  * can delete lines from this buffer any time
- to end a session
  * close the buffer or :VipsqlCloseSession
- to be prompted for SQL that is executed when return is pressed
  :VipsqlShell
- to execute a query from a Vim buffer
  * for the current line,
    :VipsqlSendCurrentLine
  * for multiple selected lines,
    select the lines and :VipsqlSendRange
  * for part of a line,
    select it and :VipsqlSendSelection
  * for the entire buffer,
    :VipsqlSendBuffer
- to kill the running query,
  :VipsqlSendInterrupt

Windows (created by splits)
  :win {width} {height} - to set default gvim window size (put in .vimrc);
  :sp[lit] [{name}]  - horizontal split screen into two windows
                       and optionally open file {name}
  :Se                - horizontal split screen and explore
  ctrl-w s           - same as :split
  :vs[plit] [{name}] - vertical split screen
  :Ve                - vertical split screen and explore
  ctrl-w v           - same as :vsplit
  :new               - split screen and start new file
  ctrl-w n           - same as :new
  ctrl-w {h|j|k|l}   - move to window in direction of key
  ctrl-w {H|J|K|L}   - swap windows in direction of key
                       * H and L switch from horizontal to vertical splits
                       * J and K switch from vertical to horizontal splits
  ctrl-w r           - rotate windows
  ctrl-w down-arrow  - move to window below
  ctrl-w up-arrow    - move to window above
  ctrl-w _           - maximize height of current window (decreases others to one line)
  ctrl-w |           - maximize width of current window (decreases others to one column)
  ctrl-w ctrl-w      - move to next window
  :clo[se]           - close current window (doesn't delete buffer)
  :clo[se]!          - close current window and discard changes
  ctrl-w c           - same as :close
  :on[ly]            - close all windows but current one
  ctrl-w o           - same as :only
  ctrl-w =           - make split windows equal width or height
  {n}ctrl-w <        - decrease window width by {n}
  {n}ctrl-w >        - increase window width by {n}
  {n}ctrl-w +        - increase window height by {n}
  {n}ctrl-w -        - decrease window height by {n}

Working Directory
- to see, :pwd
- to change, :cd {path}
  * :cd .. to go up to parent directory
  * :cd - to return to previousl working directory
  * :cd %:h - to change directory to that of the file in the current buffer
  * enter :cd and press tab key to cycle through subdirectory names
- affects filename completion

YouCompleteMe (YCM)
- a fuzzy-search code completion engine for Vim.
- see https://github.com/Valloric/YouCompleteMe
- can make Vim startup very slow!
  * maybe due to time required to start the Python-based YCM server
  * starts a new Python process for each Vim session
- uses several completion engines
  * integrates with Vim's Omnicomplete and Exhuberant Ctags
  * determines which to use based on context
- keys
  * don't have to press any key to get suggestion list; appears automatically
  * to further filter suggestion list, continue typing
  * press tab or down arrow to select first suggestion
  * press tab or down arrow repeatedly to move to next suggestion
  * press shift-tab or up arrow to move to previous suggestions
  * to accept selected suggestion, just continue typing
  * press ctrl-space to get context-specific suggestions
    even if no characters have been entered
- suggestions are based on typed characters appearing in order in them
  * ex. typing "cm" could suggest YouCompleteMe
  * typed lowercase letters match any case, but
    typed uppercase letters only match uppercase letters
  * matches at word boundaries appear higher in suggestion list
    - first letter of each word (my word boundaries)
    - uppercase letters in camel-cased words (myWordBoundaries)
    - match the examples above by typing "mwb" or "wb"
- provides programming language-specific semantic completions
  * ex. type ., ->, or :: to get possible property/method names
    - only for class/static methods?
  * more support for C-family langauges and Python than others
    - uses omnifunc for languages without a semantic completion engine
  * JavaScript example
    - enter "document." to get a list of all methods on the document object
- file-name completion to insert file names in file being edited
  * type ./ or ../ to begin
  * not used for all file types (ex. not in .txt files)
- to install
  * cd .vim/pack/plugins/start
  * git clone https://github.com/Valloric/YouCompleteMe.git
  * cd YouCompleteMe
  * python install.py
  * git submodule update --init --recursive
  * install CMake
    - on Mac OS X, brew install cmake
    - in Cygwin, is install through setup-x86.exe
  * this plugin has a compiled component
    - cd ~/.vim/pack/plugins/start/YouCompleteMe
    - for JavaScript support, ./install.py --tern-completer
    - Are the rest of these steps really needed?
    - cd
    - mkdir ycm_build
    - cd ycm_build
    - cmake -G "Unix Makefiles" . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp
- to update
  - cd MyUnixEnv/.vim/pack/plugins/start/YouCompleteMe
  - git pull
  - ./install.sh
- integrates with UltiSnips
  * but use of tab key conflicts
    - see key mapping suggestions in UltiSnips section
- to enable completion inside comments,
  let g:ycm_complete_in_comments = 1
- to enable completion inside strings,
  let g:ycm_complete_in_strings = 1
- to collect identifiers (possible completions) from comments and strings
  let g:ycm_collect_identifiers_from_comments_and_strings = 1
- to collect identifiers from tags files
  let g:ycm_collect_identifiers_from_tags_files = 1
  * requires use of Exhuberant Ctags, not plain Ctags
  * must generate tags file with  "ctags -R --fields=+l" (lowercase L)
  * makes Vim unusably slow and causes an error on all completions!
    - error is "-- User defined completion (^U^N^P) Pattern not found"
- mailing list: Google Groups ycm-users

Other
  :h[elp] {topic} - get help
    To navigate to topics surrounded by vertical bars
    put cursor on topic and press ctrl-]
  ~ - change case of char under cursor or every character
      selected in visual mode
  J - join current line with next line
  u - undo last change
  U - undo all changes on current line
  ctrl-r - redo last undo
  :earlier 15m
  - reverts the document back to how it was 15 minutes ago
  - can take various arguments for the amount of time you
    want to roll back, and is dependent on undolevels
  - can be reversed with the opposite command :later
  ctrl-l - refreshes display (useful if it gets scrambled)
  . - repeat last non-colon (ex) command
  :hardcopy - sends to printer
  :set nu[mber] - displays line numbers (you mapped <leader>n to toggle this)
  :set nonu[mber] - undisplays line numbers
  :set relative - displays relative line numbers (from current line)
  - current line gets absolute line number
  :set norelative - undisplays relative line numbers
  :set et or expandtab - future tabs are expanded to spaces
  :retab - expands all tabs currently in file to spaces
           if the previous option is set
  :!{os-cmd} - executes an OS command from within Vim (ex. :!ls)
  @: repeats the last ex command
  :so[urce] {file} - executes a file containing Ex commands such as .vimrc
  - you have <leader>ev mapped to edit .vimrc
    and <leader>sv mapped to source .vimrc
  :set wm=5 or wrapmargin -
    sets the wrap margin so that text automatically wraps
    as it is entered when it is less then 5 characters
    from the right edge of the window
    To disable, set textwidth to zero with ":set tw=0".
  :make - runs Makefile in current directory
  gd - go to definition of method or variable under cursor
  K - go to man page for word under cursor
  ctrl-g - display name of file being edited, # of lines, % thru
  % - find matching {}, () or []
  To avoid line wrap
    :set nowrap textwidth=0 wrapmargin=0
  To wrap lines at the window edge
    :set wrap nolinebreak textwidth=0 wrapmargin=0
  To break lines with hard line breaks and make them <= 80
    :set textwidth=80
  To send a buffer to a shell command
    :w !{command}
    For example, to execute Ruby code in a buffer, :w !ruby
    Can map the following to a key to save all open files
    and run the current buffer.
    :wall<CR>:!ruby %<CR>

Notes from Bill Odom's talk on 2/16/12

Google "recommended Vim plugins for JavaScript coding"
#1 JavaScript indenter - by Preston Koprivica
#2 Vastly improved javascript indentation - by Darrick Wiebe
default syntax highlighting for JavaScript just uses highlighting for C?
JSLint - see link from crypticswarm blog to Jonathan Palardy page
JSHint - manalang jshint.vim - is this what you are using?
see "Resources" slides in his deck
Bufexplorer
Taglist - works with exuberant-ctags; runs it for you
DoctorJS - from Mozilla; tags JavaScript source files
Yehuda Katz article "Everyone Who Tried to Convice Me to use Vim was Wrong"
- Bill doesn't like his recommended list of plugins for newbies
See Steven Pritchard's minimal Vim environment
http://vimcasts.org/ - a book is in the works
