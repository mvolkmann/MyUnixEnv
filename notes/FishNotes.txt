Fish Shell Notes

For article
- create example script in Fish, Bash, and Node
  that lists files containing given text in their name
  in tree form that colors file types differently
  (ex. red for .js, blue for .scss, ...)
  * maybe make colors configurable

Help
- help command-name
  * opens browser to fish shell help page
- man command-name
  * displays same help in terminal
- browse https://fishshell.com/
- browse https://github.com/jbucaran/fish-shell-cookbook
- to get help on any fish command, man {command}
  * ex. man function; man if, man switch

Installing
- browse https://fishshell.com/
  and search for "Go Fish"
- for macOS there is an installer
  and can run "brew install fish"
- for Window, can only run in Cygwin

Making default shell
- chsh -s /usr/local/bin/fish

Configuring
- can configure from shell, in a configuration file, and in the web UI
- configuration file
  * ~/.config/fish/config.fish
- web UI
  * to start, fish_config [starting-tab-name]
  * tabs include
    - colors
    - prompt
    - functions
    - variables
      * can only view values of current variables
      * is this only universal variables?
    - history
    - bindings
    - abbreviations
- 

Colors
- all colors are customizable
- colors mentioned below are the defaults
- when entering commands,
  text is red until a valid command is entered
  and then it changes to white
- when typing file paths, the text is underlined
  unless no directory or file matches what has been typed

Aliases
- to define an alias
  * alias name "{command}"
  * defines a function with the specified name that runs the command
    - not actually written to files under ~/.config/fish/functions
  * only available in the current session, unlike abbreviations
    - so abbreviations are preferred
- to list all aliases
  * alias
- to undefine an alias
  * erase the function with: functions -e name

Abbreviations
- similar to aliases, but expand when typed
- available in all sessions, unlike aliases
- to define
  * abbr name value
- to list all abbreviations
  * abbr
- to undefine (erase) an alias
  * abbr -e name

Commands
- command arguments are just separated by spaces
- to include a space in an argument,
  preceded space with a backslash or
  enclose argument in single or double quotes
- to execute multiple commands on one line,
  separate with semicolons
- all commands set the "status" environment variable to
  0 for success and another number for failure
- to execute one command and then execute a second command
  only if the first is successful
  * command1; and command2
  * note the semicolon at end of first command
  * note the use of "and" instead of "&&" like in bash
  * also uses "or" instead of "||" like in bash

Variables
- set with: set {name} {value}
  * by default variables are local to the block where they are defined
    - can specify with -l (--local), but this is the default
  * to make them global to the session, add -g option (--global)
    - really visible to everything in the same process?
  * to export them so they are visible in child processes,
    add -x option (--export)
  * to make them universal so they are
    shared between all processes on the current computer
    and saved across restarts, add -U option (--universal)
  * already defined, the scope cannot be changed
    - erase it and then set again
- How can you determine the scope of a given variable?
- variable names are case-sensitive
  * myvar and myVar are different variables
- delete (erase) with: set -e {name} (--erase)
- query (determine if set) with: set -q {name} (--query)
  * sets status variable to 0 if defined and 1 if not
    - to see, echo $status
  * to see value, echo ${name}
- list names and values of all variables: set
- list names of all defined variables: set -n (--names)
  * this may abbreviate long names
  * to avoid, use -L (--long)

Strings
- literals are delimited by single or double quotes
  * ex. set name 'Mark Volkmann'
- to get length
  * string length $name
- indexed starting at 1
- the "string" command has many "subcommands"
- to get a substring
  * string sub $name -s startIndex -l length
  * if -s is omitted, it defaults to 1
  * if -l is omitted, gets to end
  * if -s is negative, it counts from end
    - ex. to get last three characters, use -s -3
- to set a new variable to a substring
  * set newVar (string sub $name ...)
- to split a string on a delimiter, resulting in a list
  * string split delim $var
  * ex.
    set csv 'red,green,blue'
    set colors (string split , $csv)
- to concatenate a literal string with the value of a variable
  * ex.
    set middle 'some middle'
    set result 'some prefix'$middle'some suffix'

Dates
- date command returns current date by default
- format using a format string defined by strftime
  * http://man7.org/linux/man-pages/man3/strftime.3.html
- ex. date "+%A %B %d, %G" # Tuesday, August 15, 2017

Command Substitution
- to use the output of a command in the value of a variable
  * surround command with parens, not backticks like in some other shells
  * ex.
    set dateFormat "+%A %B %d, %G" # ex. Tuesday, August 15, 2017
    set announcement "Today is "(date $dateFormat)"."

Eval
- evaluates a command in a string
  that can be built using concatention and variable substitution
- ex.
  set extension '.js'
  set command ls *.$extension
  eval $command

Lists
- all variables in fish are lists that hold zero, one, or more string values
- lists cannot contain other lists
- to create an empty list
  * set myList
- to create a non-empty list
  * set myList item1 item2 ...
- to append
  * set myList $myList newItem
- to prepend
  * set myList newItem $myList
- to get an items by index
  * myList[index]
  * use negative indexes to retrieve from end
    - myList[-1] gets last item
- get a slice which is a new list
  * myList[start..end]
  * start and end can be positive or negative
- to test whether an item is in a list
  * if contains someItem $myList
      # code goes here
    end
  * contains sets status to 0 if found and 1 if not
- to remove an item
  * if set -l index (contains -i someItem $myList)
      set -e myList[$index]
    end
  * see .config/fish/functions/listrm.fish
    - TRY TO FIX ISSUE IN THIS!
- to get the length of a list
  * count $myList
- to iterate over all items in a list
  * for item in $myList
      # use item here
    end
- adjacent lists
  * result in cartesian products
  * ex.
    set columns a b c
    set rows 1 2
    set cells $columns$rows # a1 b1 c1 a2 b2 c2
    count $cells # 6
    set labels "Column "$columns # Column a Column b Column c
    count $labels # 3
- conversion to lists
  * when a fish shell is started,
    if the variables PATH, CDPATH, or MANPATH exist,
    they are converted to lists by splitting on colons

Hashmaps
- not currently supported, but discussed here:
  https://github.com/fish-shell/fish-shell/issues/390
- can simulate with plain variables,
  but can't iterate over the keys unless they are held in a list
  ex. set colors red green blue
      set items-red fire
      set items-green grass
      set items-blue water
      for color in colors
        eval echo '$'items-$color
      end

PATH environment variable
- a universal variable that holds a list of paths
- to see current value
  * echo $PATH
  * paths are separated by spaces
- the environment variable fish_user_paths
  is automatically prepended to this
  * WHY?
- to prepend a path to PATH
  * set -U fish_user_paths $fish_user_paths {new-path}
  * outputs a warning if new-path doesn't exist but adds it anyway
  * see .config/fish/functions/addpath.fish
- to remove a path from PATH
  * if set -l index (contains -i {some-path} $fish_user_paths)
      set -e fish_user_paths[$index]
    end
  * sure this is a mess, but is it easier in bash?
  * see .config/fish/functions/rmpath.fish

Functions
- to define a function
  * function myname
      # code goes here
    end
- all functions are public
  * use prefixes for "private" functions
    to avoid name conflicts
    * ex. _myprefix_myname
- to make available in future sessions
  * define in files under .config/fish/functions
  * this files are loaded the first time the function they define is called
  * name of file must match name of function
    - the autoloading mechanism for functions requires this
    - ex. define function foo in file named foo.fish
  * functions defined in these files are not loaded
    until the first time the function is called
  * can define multiple functions in the same file,
    but they will not be available until the function
    whose name matches the file is called once
    - so doing this is not recommended
- to save a function definition that has been entered interactively
  under .config/fish/functions
  * funcsave myname
  * uses tabs for indentation
- to output the code for a function
  * functions myname
- functions can be use as command-line commands
  * after changes, may need to start a new shell
- to call a function, must specify its name
  * no parens around arguments or commas between them
- can use "return" to exit before end
- to list all currently defined functions
  * functions
  * to view in web UI
    - fish_config functions
- accessing function arguments
  * use $argv list
    - first argument is in $argv[1]
- options
  * to process command-line arguments as options
    for option in $argv
      switch "$option"
        case -h --help
          # code here
        ...
        case '*'
          # code here
      end
    end
- Can a function definition be deleted?

Types of commands
- three types: builtins, commands, and functions
- builtins
  * provided by the shell
  * examples include: contains, echo, and if
  * to get a list of builtin names
    - builtin --names (or -n)
    - the "builtin" command can also be used to
      execute a specific builtin instead of a
      command or function with the same name
- commands
  * executables found in PATH
  * ex. chmod, ls, node, and vim
  * to get information about a command
    - command name
  * to get the path to a command
    - command --search name
      or
      which name
    - the "command" command can also be used to
      execute a specific command instead of a
      builtin or function with the same name
- functions
  * some are provided by fish
    ex. abbr, cd, eval
  * user-defined functions can be defined in .fish files
    under ~/.config/fish/functions
  * aliases are converted to functions
  * there are many fish-specific functions
    whose names begin with "fish_"
  * to determine if a function is defined
    - functions --query name
      * sets status to 0 if defined or 1 if not
- to get the type of a name
  * type name
  * for functions, this also outputs their definition

If statements
- if {condition}
    {statements}
  else if {condition}
    {statements}
  else
    {statements}
  end

Switch statements
- switch {expression} # ex. $color
  case {value1} {value2}
    {statements}
  case {value3}
    {statements}
  case '*' # like default in other languages
    {statements}
  end
- each case can be followed by one or more values
- does not fall through, no break at end of each case

Loops
- see "List" section for iterating over items in a list

Multiple statements on same line
- separate by semicolons
- ex. function foo; echo in foo; end

Custom Prompt
- the default fish prompt displays whoami, hostname,
  the abbreviated working directory, and ">"
- to customize, create ~/.config/fish/functions/fish_prompt.fish
- if custom prompt doesn't fit in terminal width,
  it will use just "> " instead
- ex.
function fish_prompt
  # Get the current Git branch.
  # This will be an empty string if not in a Git repo.
  set git_branch (git rev-parse --abbrev-ref HEAD ^/dev/null)

  # If in a Git repo (-q for quiet) ...
  if string length -q $git_branch
    set branch " ($git_branch)"
  else
    set branch ''
  end

  set_color --bold brblue
  echo -n $PWD # -n suppresses newline at end
  set_color --bold yellow
  echo $branch
  set_color normal
  echo -n 'üê†  '
end

Reading from stdin
- read var
  * waits for user to enter something,
    terminated by enter key
  * sets var to what user entered
- options
  * --command text or -c text
    - sets initial text as if user had entered it
    - users can modify this
  * same options as "set" for choosing scope of variable
    - includes -l (local), -g (global), -x (export), and -U (universal)
  * --silent or -i to mask input (ex. for passwords)
  * --prompt-str text or -P text
    - sets prompt text
  * --prompt-cmd text or -p text
    - sets prompt command that outputs the prompt
    - useful for dynamic prompts
  * --array or -a
    - sets variable to a list of the words entered
  * and many more
- can have more than one variable
  * sets each to the word at the corresponding position
  * last variable gets all remaining workds
  * ex. read first second
    - if user enters "foo bar baz",
      first is set to "foo" and
      second is set to "bar baz"

Reading Files
- to iterate over lines in a file
  direct a file into a loop as follows:
  while read line
    # do something with the line
  end < file-path

Redirecting output
- to redirect stdout (^ or 2>) to a file
  for the execution of a single command
  someCommand ^ 'file-path'
- to redirect stderr (>) to a file
  for the execution of a single command
  someCommand > 'file-path'
- to redirect stderr to stdout
  someCommand 2>&1

Document how to use the "spin" function you installed.
