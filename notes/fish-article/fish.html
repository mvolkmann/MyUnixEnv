<!DOCTYPE html>
<html>
  <head>
    <title>The fish Shell</title>
    <style type="text/css">
      body {
        font-family: sans-serif;
        margin: 20px 40px;
      }
      code {
        background-color: lightyellow;
        font-weight: bold;
        padding: 3px 2px;
      }
      div {
        margin-bottom: 10px;
      }
      #fish-logo {
        width: 300px;
      }
      h1, h3 {
        color: blue;
      }
      h2 {
        border-top: solid red 3px;
        color: purple;
        padding-top: 20px;
        text-decoration: underline;
      }
      h4 {
        color: purple;
      }
      img {
        margin: 10px 0;
        width: 800px;
      }
      pre {
        background-color: lightyellow;
        font-weight: bold;
        width: 800px;
      }
      .toc > .level1 {
        font-weight: bold;
        margin-left: 0;
        margin-top: 10px;
      }
      .toc > li {
        margin-left: 20px;
      }

      @media print {
        margin: 1in;
      }
    </style>
  </head>
  <body>
    <h1>The fish Shell</h1>
    <div>
      by Mark Volkmann<br>
      mark@objectcomputing.com<br>
      Object Computing, Inc.<br>
      November 2017
    </div>
    <h4>
      Come for the colors and autocomplete,
      stay for the sane scripting!
    </h4>
    <img id="fish-logo" src="fish-logo.png" alt="fish logo">

    <h3>Table of Contents</h3>
    <ul class="toc">
      <li class="level1"><a href="#Overview">Overview</a></li>
      <li><a href="#License">License</a></li>
      <li><a href="#Goals">Goals</a></li>
      <li><a href="#History">History</a></li>
      <li><a href="#Sections">Sections</a></li>

      <li class="level1"><a href="#UsingFish">Using Fish</a></li>
      <li><a href="#Installing">Installing</a></li>
      <li><a href="#DefaultShell">Default Shell</a></li>
      <li><a href="#Uninstalling">Uninstalling</a></li>
      <li><a href="#Help">Help</a></li>
      <li><a href="#StartingFish">Starting Fish</a></li>
      <li><a href="#Autosuggestions">Autosuggestions</a></li>
      <li><a href="#TabCompletions">Tab Completions</a></li>
      <li><a href="#CustomTabCompletions">Custom Tab Completions</a></li>
      <li><a href="#CommandHistory">Command History</a></li>
      <li><a href="#ChangingWorkingDirectory">Changing Working Directory</a></li>
      <li><a href="#Commands">Commands</a></li>

      <li class="level1"><a href="#CustomizingFish">Customizing Fish</a></li>
      <li><a href="#ConfigurationViaWebUi">Configuration via Web UI</a></li>
      <li><a href="#ColorTab">Color Tab</a></li>
      <li><a href="#PromptTab">Prompt Tab</a></li>
      <li><a href="#FunctionsTab">Functions Tab</a></li>
      <li><a href="#VariablesTab">Variables Tab</a></li>
      <li><a href="#HistoryTab">History Tab</a></li>
      <li><a href="#BindingsTab">Bindings Tab</a></li>
      <li><a href="#AbbreviationsTab">Abbreviations Tab</a></li>
      <li><a href="#ConfigurationServer">Configuration Server</a></li>
      <li><a href="#ConfigurationViaFishConfig">Configuration via fish.config</a></li>
      <li><a href="#Aliases">Aliases</a></li>
      <li><a href="#Abbreviations">Abbreviations</a></li>
      <li><a href="#Variables">Variables</a></li>
      <li><a href="#Strings">Strings</a></li>
      <li><a href="#RegularExpressions">Regular Expressions</a></li>
      <li><a href="#Numbers">Numbers</a></li>
      <li><a href="#Math">Math</a></li>
      <li><a href="#Dates">Dates</a></li>
      <li><a href="#Lists">Lists (a.k.a Arrays)</a></li>
      <li><a href="#Hashmaps">Hashmaps</a></li>
      <li><a href="#Path">PATH environment variable</a></li>
      <li><a href="#FunctionsAndAutoLoading">Functions and Auto-loading</a></li>

      <li class="level1"><a href="#ScriptingInFish">Scripting in Fish</a></li>
      <li><a href="#ComparingToJavaScript">Comparing fish functions to JavaScript</a></li>
      <li><a href="#ToolsForFish">Tools for fish</a></li>
      <li><a href="#echoCommand">echo Command</a></li>
      <li><a href="#Colors">Colors</a></li>
      <li><a href="#printfCommand">printf Command</a></li>
      <li><a href="#Wildcards">Wildcards</a></li>
      <li><a href="#PipesAndRedirection">Pipes and Redirection</a></li>
      <li><a href="#AdvancedUseOfVariables">Advanced Use of Variables</a></li>
      <li><a href="#SpecialVariables">Special Variables</a></li>
      <li><a href="#statusCommand">status Command</a></li>
      <li><a href="#MoreOnTests">More on Tests</a></li>
      <li><a href="#Files">Files</a></li>
      <li><a href="#CommandSubstitution">Command Substitution</a></li>
      <li><a href="#BraceExpansion">Brace Expansion</a></li>
      <li><a href="#Eval">Eval</a></li>
      <li><a href="#Functions">Functions</a></li>
      <li><a href="#AutoRunningFunctions">Auto-running Functions</a></li>
      <li><a href="#TypesOfCommands">Types of Commands</a></li>
      <li><a href="#ifCommand">if Command</a></li>
      <li><a href="#andAndOrCommands">and &amp; or Commands</a></li>
      <li><a href="#switchCommand">switch Command</a></li>
      <li><a href="#LoopCommands">Loop Commands</a></li>
      <li><a href="#MultipleStatementsOnALine">Multiple Statements on a Line</a></li>
      <li><a href="#CustomGreeting">Custom Greeting</a></li>
      <li><a href="#CustomPrompt">Custom Prompt</a></li>
      <li><a href="#ReadingFromStdin">Reading From stdin</a></li>
      <li><a href="#AbsolutePath">Absolute Path</a></li>
      <li><a href="#Processes">Processes</a></li>
      <li><a href="#Jobs">Jobs</a></li>
      <li><a href="#DebuggingFunctions">Debugging Functions</a></li>
      <li><a href="#OptionParsing">Option Parsing</a></li>

      <li class="level1"><a href="#Extras">Extras</a></li>
      <li><a href="#RandomNumbersAndOptions">Random Numbers and Options</a></li>
    </ul>

    <h3><a name="Overview">Overview</a></h3>
    <div>
      Fish is a *nix shell that offers an alternative
      to shells like bash and zsh.
      At a high level, fish provides the following benefits:
    </div>
    <ul>
      <li>auto-suggestions while typing</li>
      <li>auto-complete of commands, their switches (a.k.a. options), file paths,
        variable names, git branches, and more</li>
      <li>easy access to web-based help</li>
      <li>colorful prompts</li>
      <li>ability to customize colors and the prompt using a web UI</li>
      <li>highly consistent and simple scripting language</li>
    </ul>
    <div>
      This article explains why you might prefer fish over other shells.
      Really learning a shell is similar to learning a new programming language.
      Similar topics are covered here such as
      variables, functions, string operations, and so on.
      If writing scripts in other shells has felt tedious in the past,
      this is your chance to learn a shell that makes scripting easier!
    </div>
    <div>
      The latest version of fish at the time of this article is 2.6.0.
      TODO: This may change before this article is published!
    </div>

    <h3><a name="License">License</a></h3>
    <div>
      The fish shell uses the GNU General Public License, version 2.
      Here's a summary of that license:
    </div>
    <blockquote>
      You may copy, distribute and modify the software
      as long as you track changes/dates in source files.
      Any modifications to or software including (via compiler)
      GPL-licensed code must also be made available under the GPL
      along with build and install instructions.
    </blockquote>

    <h3><a name="Goals">Goals</a></h3>
    <div>
      The goals for fish are listed at
      <a href="https://fishshell.com/docs/current/design.html">
        https://fishshell.com/docs/current/design.html
      </a>.
      Here are the most significant goals:
    </div>
    <ul>
      <li>
        Everything that can be done in other shell languages
        should be possible to do in fish,
        though fish may rely on external commands in doing so.
     </li>
      <li>
        Fish should be user friendly, but not at the expense of expressiveness.
        Most tradeoffs between power and ease of use
        can be avoided with careful design.
     </li>
      <li>
        Whenever possible without breaking the above goals,
        fish should follow the Posix syntax.<br>
        (This may lead some to avoid using fish for
        sysadmin and install types of scripts
        because there is often a desire for those to be highly portable
        without requiring installation of new software such as fish.
        However, for scripts targeted at typical users
        or scripts that only you will use,
        implementing them in a shell that is not 100% Posix compliant
        is much less of a concern.)
     </li>
      <li>
        The shell language should have a small set of orthogonal features.
      </li>
      <li>
        Everything should be tab-completable, and
        every tab completion should have a description.
     </li>
      <li>
        Every syntax error and error in a builtin command should result in
        an error message describing what went wrong and a relevant help page.
        Whenever possible, errors should be flagged red
        by the syntax highlighter.
      </li>
      <li>
        The language should be uniform so that once
        the user understands the command/argument syntax,
        they will know the whole language and be able to
        use tab-completion to discover new features.
      </li>
    </ul>

    <h3><a name="History">History</a></h3>
    <div>
      The first release of fish was on Februrary 13, 2005.
      Axel Liljencrantz was the main developer and maintainer of
      versions 1.0 to 1.23.1 which were in SourceForge.
      The last 1.x release was in March 2009.
      Various people maintained forks at Gitorious and elsewhere,
      but it seems no releases were ever made.
      A person that goes by "ridiculousfish" got involved in late 2011
      and released a beta of a fork called "fishfish" in 2012.
      This incorporated much of the work of previous fish contributors
      and eventually became fish 2.0.
    </div>
    <div>
      fish was originally implemented in C, but is now primarily C++.
    </div>
    <div>
      fish 3.0 is targeted to be released in Q1 2018.
      For a list of fixes/features targeted for this release, see
      <a href="https://github.com/fish-shell/fish-shell/milestone/18">https://github.com/fish-shell/fish-shell/milestone/18</a>.
      For a list of additional fixes/features that *may* be in this release, see
      <a href="https://github.com/fish-shell/fish-shell/milestone/7">https://github.com/fish-shell/fish-shell/milestone/7</a>.
    </div>

    <h3><a name="Sections">Sections</a></h3>
    <div>
      The remainder of this article is split into three sections.
      The first section describes using fish.
      The second section describes customizing fish.
      The third section describes scripting in fish.
    </div>

    <h2><a name="UsingFish">Using Fish</a></h2>

    <h3><a name="Installing">Installing</a></h3>
    <div>
      Instructions for installing fish are at
      <a href="https://fishshell.com/">https://fishshell.com/</a>.
      Search that page for "Go Fish".
    </div>
    <div>
      For macOS, there is an installer.
      If <a href="https://brew.sh/">Homebrew</a> has been installed,
      fish can also be installed by entering <code>brew install fish</code>.
    </div>
    <div>
      For Windows, fish can be run in Cygwin.
      In Windows 10, fish can be run in the "Windows Subsystem for Linux" (WSL).
    </div>
    <div>
      I highly recommend installing fish now so you can try each feature
      as it is explained here.
      It's easy enough to uninstall later if desired.
    </div>

    <h3><a name="DefaultShell">Default Shell</a></h3>
    <div>
      To make fish the default shell so new terminal windows automatically use it,
      enter <code>chsh -s /usr/local/bin/fish</code>.
      Perhaps it's best to hold off on donig this until you become
      convinced that fish is for you.  I'm confident you will!
    </div>

    <h3><a name="Uninstalling">Uninstalling</a></h3>
    <div>
      This fish shell can be uninstalled by changing
      the default shell to something else (like bash)
      and running the following commands:
    </div>
    <ul>
      <li><code>rm -Rf /usr/local/etc/fish /usr/local/share/fish ~/.config/fish</code></li>
      <li><code>rm /usr/local/share/man/man1/fish*.1</code></li>
      <li><code>cd /usr/local/bin</code></li>
      <li><code>rm -f fish fish_indent</code></li>
    </ul>

    <h3><a name="Help">Help</a></h3>
    <div>
      There are many sources for help on fish.
      The main web site at
      <a href="https://fishshell.com/">https://fishshell.com/</a>
      provides excellent documentation.
      Entering just <code>help</code> in a terminal
      opens the local copy of this documentation
      for the version of fish that is installed
      in the default web browser.
    </div>
    <div>
      Entering <code>man <i>command-name</i></code>
      displays help in the terminal.
      For many commands, entering <code><i>command-name</i> -h</code>
      does the same.
    </div>
    <div>
      Entering <code>help <i>command-name</i></code>
      displays the same help in the default web browser,
      but with better formatting.
    </div>
    <div>
      Other great sources of help include:
    </div>
    <ul>
      <li>
        Github repo at
        <a href="https://github.com/fish-shell/">https://github.com/fish-shell/</a>
      </li>
      <li>
        Wikipedia page at
        <a href="https://en.wikipedia.org/wiki/Friendly_interactive_shell">https://en.wikipedia.org/wiki/Friendly_interactive_shell</a>
      </li>
      <li>
        official mailing list at
        <a href="mailto:fish-users@lists.sourceforge.net">fish-users@lists.sourceforge.net</a>
      </li>
      <li>Stackoverflow at
        <a href="https://stackoverflow.com/questions/tagged/fish">https://stackoverflow.com/questions/tagged/fish</a>
      </li>
      <li>IRC channel #fish on irc.oftc.net</li>
    </ul>

    <h3><a name="StartingFish">Starting Fish</a></h3>
    <div>
      Once fish has been installed, open a terminal.
      If fish is not the default shell, enter <code>fish</code> to start a fish shell.
      To exit a fish shell, enter <code>exit</code>.
    </div>

    <h3><a name="Autosuggestions">Autosuggestions</a></h3>
    <div>
      Autosuggestions suggest remaining text for a command
      while the command is being typed.
      Typically this appears as gray text,
      sometimes referred to as ghosting,
      but the color can be customized.
      It derives suggestions from command history,
      possible commands, possible switches,
      variables, and file paths.
    </div>
    <div>
      If the suggestion is not desired, continue typing.
      To accept a suggested completion, press the right arrow.
      To execute the command, press enter.
    </div>
    <div>
      Possible commands and switches are derived from
      man pages that fish has parsed.
      If new man pages are installed,
      enter <code>fish_update_completions</code> to parse them.
    </div>

    <h3><a name="TabCompletions">Tab Completions</a></h3>
    <div>
      Autosuggestions only provide one suggestion.
      To see more options, press tab.
      This presents a list of options that includes
      command names, switches, variable names,
      file paths,
      git branch names (including remote branches),
      process names/ids,
      job names/ids,
      man page names,
      ssh hosts,
      users,
      and more.
    </div>
    <div>
      The options presented depend on the command that has been entered.
      For example, if the <code>su</code> command has been entered,
      pressing tab displayes all known usernames.
    </div>
    <div>
      If there is only one option, it will be expanded in place.
      If there is more than one option,
      up to four rows will be listed.
      If there are more than four rows of options,
      they will be followed by "...and <i>n</i> more rows".
      To see the remaining options, press tab again.
      To select an option, press tab repeatedly until
      the desired option is highlighted.
      Highlighting cycles back to first option
      if tab is pressed while the last option is highlighted.
      When the desired option is highlighted, press enter to accept it.
      Press enter again to execute the command.
    </div>
    <div>
      To filter the list of options,
      press tab until some option is highlighted,
      then type a substring that must be contained in the options.
      A search entry field starting with "search:" will be displayed.
      To skip selecting an option, press the escape key.
    </div>
    <h4>Examples</h4>
    <div>
      To list files in the current directory whose names contain "d",
      enter <code>ls d</code> and press tab.
      This also works when only <code>ls</code> entered
      before pressing tab.  In this case the options are
      all files in the current directory.
    </div>
    <div>
      To output the value of a variable whose name begins with "re",
      enter <code>echo $re</code> and press tab repeatedly
      until the desired variable is highlighted.
      Then press enter once to select it and
      again to execute the <code>echo</code> command.
    </div>
    <div>
      To kill a process whose name contains "lo",
      enter <code>kill lo</code> and press tab repeatedly
      until the desired process is highlighted.
      Then press enter once to select it and
      again to execute the <code>kill</code> command.
    </div>
    <div>
      To get help on a command that contains "lo",
      enter <code>man lo</code> and press tab repeatedly
      until the desired command is highlighted.
      Then press enter once to select the command and
      again to execute the <code>man</code> command.
    </div>

    <h3><a name="CustomTabCompletions">Custom Tab Completions</a></h3>
    <div>
      Tab completions can be defined for custom commands
      using the <code>complete</code> command.
      This is an advanced topic.
    </div>
    <div>
      The syntax is
      <code>complete -c <i>commandName</i> -s <i>shortSwitch</i> -l <i>longSwitch</i> -a '<i>argument words</i>'</code>
    </div>
    <div>
       TODO: See your functions/greet.fish and completions/greet.fish example
       which is not working yet.
       Also see https://fishshell.com/docs/current/commands.html#complete
       and https://fishshell.com/docs/current/index.html#completion-own.
    </div>

    <h3><a name="CommandHistory">Command History</a></h3>
    <div>
      All commands entered are saved in command history,
      except those that begin with a space.
      Those are treated like incognito commands.
      This exception may be removed in fish 3.
      Duplicate commands are automatically removed,
      retaining only their most recent occurrence.
    </div>
    <div>
      A separate command history is maintained for each session,
      but new sessions start with the command history
      of the session from which they were created.
    </div>
    <div>
      Command history is stored in <code>~/.local/share/fish/fish_history</code>.
      This file stores each command and when it was entered.
    </div>
    <div>
      To navigate through all previously entered commands
      press the up and down arrow keys.
      Press enter to execute the displayed command
      or press ctrl-c to exit without executing one.
      To restrict to commands that contain a given substring,
      type the substring before pressing the arrow keys.
    </div>
    <div>
      Many commands accept switches that affect their functionality.
      Switches can have short and long forms.
      For example, the <code>grep</code> command
      can perform case insensitive matches.
      This is specified using the <code>--ignore-case</code> (long)
      or <code>-i</code> (short) switch.
      Command examples in this article always use the long forms of switches
      and commands are followed by the short form in parentheses.
    </div>
    <div>
      To list all commands in the history, enter <code>history</code>.
    </div>
    <div>
      To list only commands that contain a given substring,
      enter <code>history <i>text</i></code>.
      This is the same as entering
      <code>history search --contains <i>substring</i></code> (<code>-c</code>).
    </div>
    <div>
      To list only commands that begin with a given prefix, enter
      <code>history search --prefix <i>prefix</i></code> (<code>-p</code>).
    </div>
    <div>
      To include the date and time that commands were issued,
      add the <code>--show-time-prepends</code> (<code>-t</code>) switch.
    </div>
    <div>
      To limit the number of commands output,
      add the <code>--max</code> (<code>-n</code>) switch followed by a number.
      For example, <code>history -n 5</code>.
      Note that the space after <code>-n</code> is required.
    </div>
    <div>
      To clear all command history, enter <code>history clear</code>.
    </div>
    <div>
      To delete commands from history that contain a given substring,
      enter <code>history delete --contains <i>substring</i></code>.
    </div>
    <div>
      To delete commands from history that begin with a given prefix,
      enter <code>history delete --prefix <i>prefix</i></code> (<code>-p</code>).
    </div>

    <h3><a name="ChangingWorkingDirectory">Changing Working Directory</a></h3>
    <div>
      Like in other shells, the current working directory
      can be changed by using the <code>cd</code> command.
      However, since the initial character of directory paths
      (<code>.</code>, <code>/</code>, and <code>~</code>)
      is not a valid character in any command,
      fish interprets just entering a directory path
      as a request to change the working directory.
      For example, entering
      <code>..</code> cds to the parent directory and
      <code>~</code> cds to your home directory.
    </div>
    <div>
      Tab completion can be used to assist in
      entering each part of a directory path.
      This even works without entering anything,
      so it's possible to navigate to any child directory
      by just pressing tab repeatedly
      until the desired directory name is highlighted
      and then pressing enter once to select it
      and again to cd to it.
    </div>
    <div>
      Like in other shells, to print the current working directory
      enter <code>pwd</code>.
    </div>
    <div>
      The <code>dirh</code> command prints a
      list of the last 25 directories visited.
      The current directory will be highlighted.
      To go back one, enter <code>prevd</code> or
      press alt-left (in macOS, cmd-option-left).
      To go forward one, enter <code>nextd</code> or
      press alt-right (in macOS, cmd-option-right).
      This is a very convenient way to change to a previous directory!
    </div>
    <div>
      In addition, a stack of specific directories is maintained.
      To push a new directory onto the stack and cd to it,
      enter <code>pushd <i>directory</i></code>.
      To pop the current directory off the stack
      and cd to the directory now at the top,
      enter <code>popd</code>.
      It is not possible to pop the last directory off the stack.
      To view the current directory stack, enter <code>dirs</code>.
    </div>

    <h3><a name="Commands">Commands</a></h3>
    <div>
      Every fish command is executed by entering its name
      followed by switches and arguments, if any, separated by spaces.
      Everything in fish is done with commands.
      This includes control statements like
      <code>if</code>, <code>switch</code>,
      <code>for</code>, and <code>while</code>.
      It also includes defining functions.
      It's hard to think of another programming language
      with such a consistent syntax.
      It is somewhat like Lisp in this regard.
    </div>
    <div>
      Many switches support both a long and short form.
      Long switch names are preceded by two dashes.
      Short switch names are preceded by one dash
      and their names are a single letter.
    </div>
    <div>
      Nearly all commands set the <code>status</code> variable to
      <code>0</code> for success and another number for failure.
      <code>true</code> and <code>false</code> are not boolean literals.
      <code>true</code> is a command that sets status to 0 and
      <code>false</code> is a command that sets status to 1.
      Commands that do not set <code>status</code> include
      <code>and</code>,
      <code>begin</code>,
      <code>break</code>,
      <code>builtin</code>,
      <code>case</code>,
      <code>command</code>,
      <code>continue</code>,
      <code>else</code>,
      <code>end</code>,
      <code>for</code>,
      <code>if</code>,
      <code>or</code>,
      <code>switch</code>,
      and <code>while</code>.
      Despite being commands, most of these
      are used more like language keywords.
    </div>
    <div>
      Commands are terminated by a newline or semicolon.
      In a shell, pressing the enter key produces a newline.
      Semicolons allow multiple commands to appear on the same line.
    </div>
    <div>
      There is a short list of commands that create a "block"
      which is a set of commands.
      These include <code>block</code>,
      <code>if</code>, <code>switch</code>,
      <code>for</code>, <code>while</code>,
      and <code>function</code>.
      These commands can span any number of lines and
      are terminated when the corresponding <code>end</code> command is reached.
    </div>
    <div>
      Commands can be split over multiple lines in two ways.
      One is by pressing enter when there is an unterminated block.
      Another is by typing the <code>\</code> continuation character
      before a command has been completely entered
      and pressing the enter key.
    </div>
    <div>
      Multi-line commands can be recalled and edited
      just like single-line commands.
      After a multi-line command has been recalled,
      press the left arrow and then
      press the up and down arrows to navigate between lines.
    </div>
    <div>
      To include a space in an argument,
      precede the space with a backslash or
      enclose the argument in single or double quotes.
    </div>
    <div>
      Arguments are expanded before commands are executed.
      This includes evaluating wildcards in file paths.
    </div>
    <div>
      To execute one command and then execute a second command
      only if the first succeeded, use
      <code><i>command1</i>; and <i>command2</i></code>.
      Note the semicolon at end of the first command and the use of
      <code>and</code> instead of <code>&amp;&amp;</code> like in bash.
      <code>and</code> is not a keyword.  It is a command that executes the
      command passed to it only if the status from the previous command is zero.
      If <code><i>command1</i>; <i>command2</i></code> were used instead
      and <code><i>command1</i></code> had a bad status,
      <code><i>command2</i></code> would still be executed.
    </div>
    <div>
      To execute one command and then execute a second command
      only if the first failed, use
      <code><i>command1</i>; or <i>command2</i></code>.
      Note the semicolon at end of the first command and the use of
      <code>or</code> instead of <code>||</code> like in bash.
      <code>or</code> is not a keyword.  It is a command that executes the
      command passed to it only if the status from the previous command is non-zero.
    </div>
    <div>
      While these conventions for <code>and</code> and <code>or</code>
      may seem unusual at first,
      they follow the consistent syntax of fish
      where everything is done with commands and
      all commands are terminated with a newline or semicolon.
    </div>

    <h2><a name="CustomizingFish">Customizing Fish</a></h2>

    <div>
      The fish shell can be configured in three ways:
      by executing commands in a shell,
      adding commands in a configuration file,
      and in a web UI.
    </div>

    <h3><a name="ConfigurationViaWebUi">Configuration via Web UI</a></h3>
    <div>
      To start the web UI, enter
      <code>fish_config <i>starting-tab-name</i></code>.
      Specifying the starting tab name is optional
      and defaults to "colors".
      This command starts a local web server and
      opens a new tab in the default web browser.
      The UI contains seven tabs that are described below.
    </div>

    <h4><a name="ColorTab">Color Tab</a></h4>
    <div>
      The "colors" tab displays the current color settings
      and allows them to be customized.
      To use a provided color theme, select one,
      press the "Set Theme!" button, and
      wait a few seconds for it to change to "Theme Set!".
    </div>
    <img src="config-colors.png" alt="color config screenshot">
    <div>
      Colors can be customized for the following syntax elements:
      commands, parameters, statement terminators, quoted strings,
      redirections, errors, comments, and autosuggestions.
      To customize one of these, click the corresponding syntax example
      near the top of the UI and
      select a color from the color grid that will be displayed below.
      When finished customizing the colors, press the "Set Theme" button.
      Note that these colors are not used when files containing
      fish function definitions are simply cat'ed in a terminal.
    </div>
    <div>
      While the "color" tab allows selecting a background color,
      this is only for seeing how the other colors look
      against that background.
      It does not actually change the terminal background color.
      If using the Terminal app in macOS, the background color can be changed by
      selecting Preferences...Profiles...Background...Colors &amp; Effects.
      If using the iTerm2 app in macOS, the background color can be changed by
      selecting Preferences...Profiles...Colors...Background.
    </div>

    <h4><a name="PromptTab">Prompt Tab</a></h4>
    <div>
      The "prompt" tab displays the contents
      of the current fish shell prompt.
      It allows selection from 17 predefined prompts.
      To change the prompt, select one and press "Prompt Set!"
      DANGER: This overwrites <code>functions/fish_prompt.fish</code>,
      so if you have defined a custom prompt in that file
      and don't want to wipe it out, don't do this!
      Defining custom prompts is discussed later.
    </div>
    <img src="config-prompt.png" alt="prompt config screenshot">

    <h4><a name="FunctionsTab">Functions Tab</a></h4>
    <div>
      The "functions" tab provides a read-only view
      of all functions that have been defined.
      Select a function name to see its definition
      which includes all the commands it executes.
    </div>
    <img src="config-functions.png" alt="functions config screenshot">

    <h4><a name="VariablesTab">Variables Tab</a></h4>
    <div>
      The "variables" tab provides a read-only view
      that lists all universal variables and their values.
      This does not list global or local variables.
      The distinctions between these variable types is discussed later.
    </div>
    <img src="config-variables.png" alt="variables config screenshot">

    <h4><a name="HistoryTab">History Tab</a></h4>
    <div>
      The "history" tab provides a mostly read-only view
      of your command history in the order in which commands
      were issued from any terminal,
      starting with the most recent commands.
      To delete a command from history,
      click the circled "X" to its right.
    </div>
    <img src="config-history.png" alt="color config screenshot">

    <h4><a name="BindingsTab">Bindings Tab</a></h4>
    <div>
      The "bindings" tab provides a read-only view
      that lists the current key bindings.
    </div>
    <img src="config-bindings.png" alt="bindings config screenshot">

    <h4><a name="AbbreviationsTab">Abbreviations Tab</a></h4>
    <div>
      The "abbreviations" tab provides an editable list
      of all the abbreviations that have been defined.
      To modify an existing abbreviation, click the current command,
      change it, and press the "Save" button.
      To delete an existing abbreviations,
      click the circled "X" to its right.
      To add a new abbreviation, enter a name and a command
      in the two inputs at the bottom and press the "Save" button.
      one for the name and one for the associated command.
      Changing the name of an existing abbreviation
      creates a new abbreviation with that name,
      but doesn't delete the existing one.
      Often abbreviations are defined in <code>config.fish</code>
      (discussed later), but they can also be defined from a terminal.
    </div>
    <img src="config-abbreviations.png" alt="abbreviations config screenshot">

    <h4><a name="ConfigurationServer">Configuration Server</a></h4>
    <div>
      Pressing the enter key in the terminal where
      the <code>fish_config</code> command was entered
      shuts down the server that serves this web UI.
      To restart it, enter <code>fish_config</code> again,
      which will also open a new browser tab.
    </div>

    <h3><a name="ConfigurationViaFishConfig">Configuration via fish.config</a></h3>
    <div>
      Fish is billed as not needing configuation.
      Strictly speaking this is true,
      but if you currently use another shell like bash,
      you likely have configuration for it
      (in <code>~/.bash_profile</code> and <code>~/.bashrc</code>)
      and will want similar configuration for fish.
      Examples include creating aliases and abbreviations,
      and setting variables such as <code>PATH</code>.
    </div>
    <div>
      The fish configuration file is named <code>config.fish</code>
      and should be placed in the <code>~/.config/fish</code> directory.
      Saving configuration in this file enables
      copying the file to other machines
      where the same configuration is desired.
    </div>
    <div>
      A "login shell" is created for every new terminal window.
      For users of tmux, this includes creating new tmux panes.
      An "interactive shell" is one in which a user
      can enter commands and see their output.
      They are created when a subshell is created.
      For example, this happens when the command <code>fish</code>
      is entered in a fish shell.
      Login shells are also interactive shells.
      When a shell script is run, a new non-interactive shell
      is created and is used to run the script.
    </div>
    <div>
      Inside <code>config.fish</code>,
      to run commands only when starting a login shell,
      place the commands inside an <code>if</code> command as follows:
      <code>if status --is-login; ...; end</code>.
      To run commands only when starting an interactive shell, use
      <code>if status --is-interactive; ...; end</code>.
    </div>
    <div>
      While functions can be defined in <code>config.fish</code>,
      it is more efficient to use autoloading functions.
      These are discussed later.
    </div>

    <h3><a name="Aliases">Aliases</a></h3>
    <div>
      An alias is an alternate name, usually shorter, for some command.
    </div>
    <div>
      To define an alias, enter <code>alias name <i>command</i></code>.
    </div>
    <div>
      To list all aliases, enter <code>alias</code>.
    </div>
    <div>
      To remove an alias, enter <code>functions --erase <i>name</i></code> (<code>-e</code>).
    </div>
    <div>
      Defining an alias creates a function with the specified name
      that runs when the alias is used as a command.
      Functions are described later.
      The function is only defined in the current session
      and goes away when the session exits.
      To create aliases that are available in all future sessions,
      define them in <code>config.fish</code>.
      For more information, see "Defining aliases" at
      <a href="https://fishshell.com/docs/current/index.html#introduction" target="_blank">https://fishshell.com/docs/current/index.html#introduction</a>.
    </div>

    <h3><a name="Abbreviations">Abbreviations</a></h3>
    <div>
      In addition to aliases, fish supports abbreviations.
      These are similar, but expand when typed.
    </div>
    <div>
      To define an abbreviation, enter
      <code>abbr --add <i>name</i> <i>value</i></code> (<code>-a</code>).
    </div>
    <div>
      For example, the following defines an abbreviation
      for checking out a git branch:
      <code>abbr --add co git checkout</code>.
      Once this is defined, <code>co</code> followed by a space can be entered
      in a terminal and that will expand to <code>git checkout</code>.
      Continue typing a branch name and press enter to execute the command.
      The branch name is often auto-suggested and can be tab completed.
    </div>
    <div>
      Unlike aliases, when abbreviations are defined in a terminal
      (as opposed to inside <code>config.fish</code>),
      they become available in all current and future sessions.
    </div>
    <div>
      In general, abbreviations are preferred over aliases.
    </div>
    <div>
      To output a list of all abbreviation names,
      enter <code>abbr --list</code> (<code>-l</code>).
    </div>
    <div>
      To output a list of all abbreviation names and their values,
      enter <code>abbr --show</code> (<code>-s</code>)
      or just <code>abbr</code>.
    </div>
    <div>
      To delete (erase) an alias,
      enter <code>abbr --erase <i>name</i></code> (<code>-e</code>).
    </div>

    <h3><a name="Variables">Variables</a></h3>
    <div>
      Variable names in fish consist of letters, digits, and underscores.
      Unlike variable names in most programming languages,
      these can begin with a digit.
      All variable values are lists that hold zero, one, or more string values,
      although most have only one.
      Variable names are case-sensitive, so
      <code>myvar</code> and <code>myVar</code> are different variables.
    </div>
    <div>
      There are three variable scopes.
    </div>
    <div>
      <b>Local variables</b> available only in the current block.
      Blocks begin with one of these commands,
      each of which are discussed later:
      <code>begin</code>, <code>if</code>, <code>for</code>,
      <code>function</code> , <code>switch</code>,
      or <code>while</code>.
      Blocks are terminated by a corresponding <code>end</code> command.
    </div>
    <div>
      <b>Global variables</b> are available anywhere in the current session.
    </div>
    <div>
      <b>Universal variables</b> are available in every session.
      They are even available in future sessions
      because they are saved across reboots.
      Settings of universal variables are stored in
      <code>~/.config/fish/fishd.<i>machine-id</i></code>.
    </div>
    <div>
      Regardless of scope, every variable is set using the command
      <code>set <i>name</i> <i>value</i></code>.
      This command accepts many switches.
    </div>
    <div>
      To make a variable local, add <code>--local</code> (<code>-l</code>).<br>
      To make a variable global, add <code>--global</code> (<code>-g</code>).<br>
      To make a variable universal, add <code>--universal</code> (<code>-U</code>).<br>
      To export a variable so it is visible in child processes,
      add <code>--export</code> (<code>-x</code>).
      Note that this is not a new kind of scope.
      It is convention for exported variable names to be all uppercase.
    </div>
    <div>
      The same variable name can be assigned a different value
      in each scope.  The value used depends on context,
      using the lowest visible scope, local then global then universal.
    </div>
    <div>
      What happens when a variable is set without specifying a scope
      depends on whether it has been previously set.
      If the variable has already been set in any scope,
      this changes the value of the lowest visible scope already set.
      If the variable has not already been set in any scope,
      the new variable will be local to the function in which it is set,
      not the block where it is set.
      If not in a function, the variable will be global.
      When a variable is set in <code>config.fish</code>
      with no scope switch, it becomes global.
    </div>
    <div>
      To get the value of a variable use <code>$<i>name</i></code>.
      If this appears next to other text,
      say the strings <code>foo</code> and <code>bar</code>,
      use <code>foo{$<i>name</i>}bar</code>
      or <code>'foo'$<i>name</i>'bar'</code>.
    </div>
    <div>
      To delete (or erase) a variable,
      enter <code>set --erase <i>name</i></code> (<code>-e</code>).
      This will delete the variable from the closest scope
      in which it is currently defined,
      considering local then global then universal.
      A scope can also be specified using the
      <code>--local</code> (<code>-l</code>),
      <code>--global</code> (<code>-g</code>), and
      <code>--universal</code> (<code>-U</code>) switches.
    </div>
    <div>
      To list the names and values of all variables
      in the lowest in which they can be found,
      enter <code>set</code>.
      A scope switch can also be specified
      to list only the variables in that scope.
      To list all variables that have been exported,
      add the <code>--export</code> (<code>-x</code>) switch.
    </div>
    <div>
      To list only the names of all defined variables,
      enter <code>set --names</code> (<code>-n</code>).
      A scope switch can also be specified
      to list only the variable names in that scope.
    </div>
    <div>
      To determine if a variable has been set (query),
      enter <code>set --query <i>name</i></code> (<code>-q</code>).
      This sets the status variable to 0 if set and 1 if not.
      For example, <code>set -q fish_greeting; echo $status</code>.
      A scope switch can also be specified to query only in that scope.
    </div>
    <div>
      A variable can be set and not have a value.
      For example, <code>set foo</code>
      sets the variable <code>foo</code>, but it doesn't have a value.
      For JavaScript developers, this is similar to setting a variable
      to <code>null</code> (has a value)
      versus <code>undefined</code> (has no value).
      To determine if a variable has a value,
      enter <code>set -q <i>name</i>[0]</code>
      and verify that <code>status</code> is set to zero.
    </div>
    <div>
      To interactively edit the value of a variable,
      enter <code>vared <i>name</i></code>.
      This is useful for values that are long strings.
      It cannot be used to edit values that are lists
      containing more than one item.
      To edit a specific item in a list,
      specify the item index.
      For example, if the variable <code>colors</code> holds a list of colors,
      the third color can be edited with <code>vared colors[3]</code>.
    </div>
    <div>
      Currently there is no way to request the value of a variable
      in a specific scope.  Version 2.7 of fish will add
      a <code>--show</code> switch to the <code>set</code> command.
      To display information about a given variable name
      in all scopes in which it is defined,
      you will be able to enter
      <code>set --show <i>name</i></code>.
      This version of fish will likely be released in September 2017.
      TODO: This may be out before this article is published!
    </div>

    <h3><a name="Strings">Strings</a></h3>
    <div>
      Literal string values are specified by enclosing text
      in single or double quotes.
      Variable substitution occurs in double quotes, but not in single.
      For example, the reference to <code>$USER</code>
      in the following is replaced by its value:
      <code>set msg "Good morning, $USER. Have a great day!"</code>
    </div>
    <div>
      In a single quoted string,
      single quotes can be escaped with <code>\'</code>.
      In a double quoted string,
      double quotes can be escaped with <code>\"</code> and
      <code>$</code> (which is used for variable substitution)
      can be escaped with <code>\$</code>.
      In both kinds of strings,
      backslashes can be escaped with <code>\\</code>.
    </div>
    <div>
      The <code>string</code> command has many subcommands
      that are specified by following <code>string</code>
      with a space and the name of the subcommand.
      To suppress output from these and
      just use the value of the <code>status</code> variable,
      add the <code>--quiet</code> (<code>-q</code>) switch.
    </div>
    <div>
      To get the length of a string, use
      <code>string length $<i>name</i></code>.
    </div>
    <div>
      Literal strings can be concatenated with the value of a variable.
      For example,
    </div>
    <pre>
set middle 'some middle'
set result 'some prefix'$middle'some suffix'</pre>
    <div>
      These are similar, but result in a list with a count of 3.
    </div>
    <pre>
set result some prefix"$middle"some suffix
set result some prefix{$middle}some suffix</pre>
    <div>
      Here are some tests than can be performed on
      variables that hold a single string.
    </div>
    <ul>
      <li>is empty: <code>if test -z "$<i>var</i>"</code></li>
      <li>is not empty: <code>if test -n "$<i>var</i>"</code></li>
      <li>is identical to another: <code>if "$<i>var1</i>" = "$<i>var2</i>"</code></li>
      <li>is not identical to another: <code>if "$<i>var1</i>" != "$<i>var2</i>"</code></li>
    </ul>
    <div>
      To test the relationship between two strings in sorting order,
      use the <code>expr</code> command.
      This evaluates an expression where each operand and operator
      is passed as a separate argument.
      It returns <code>1</code> if the expression evaluates to true
      and <code>0</code> if false,
      which is opposite from how command status values are set.
    </div>
    <div>
      For example, to determine if a string in the variable <code>v1</code>
      is less than or equal to a string in the variable <code>v2</code>, use:
    </div>
    <pre>
if expr $v1 '&lt;=' $v2
  # code goes here
end</pre>
    <div>
      Note that <code>expr</code> coerces strings to numbers if it can,
      so <code>expr '3' '&lt;' '12'</code> outputs 1 for true
      despite the fact that the string <code>'3'</code>
      sorts after the string <code>'12'</code>.
    </div>
    <div>
      To get a substring, use
      <code>string sub $<i>name</i> --start <i>startIndex</i> --length <i>length</i></code>
      (<code>-s</code> and <code>-l</code>).
      String indexes start at 1, not 0.
      If <code>-s</code> is omitted, it defaults to <code>1</code>.
      If <code>-l</code> is omitted, this gets characters to the end.
      If <code>-s</code> is negative, it counts from the end of the string.
      For example, to get last three characters, use <code>-s -3</code>.
    </div>
    <div>
      To split a string on a delimiter resulting in a list, use
      <code>string split <i>delim</i> $<i>var</i></code><br>
      For example,
    </div>
    <pre>
      set csv 'red,green,blue'
      set colors (string split , $csv) # red green blue</pre>
    <div>
      Note that in the previous line the <code>string split</code> command
      was surrounded by parentheses.  This allows its stdout to be captured.
    </div>
    <div>
      To trim leading and/or trailing characters, use
      <code>string trim $<i>var</i></code><br>
      By default, this trims whitespace from both ends of the string.
      Switches can be used to change this.
    </div>
    <ul>
      <li><code>--left</code> (<code>-l</code>) only trims from left</li>
      <li><code>--right</code> (<code>-r</code>) only trim from right</li>
      <li><code>--chars</code> (<code>-c</code>) specifies the
        characters to be trimmed instead of just whitespace</li>
    </ul>
    <div>
      For example, to remove leading zeros,
    </div>
    <pre>
set myText '00019'
set result (string trim --left --chars 0 $myText) # 19</pre>
    <div>
      To create a new string by joining existing ones
      using a delimiter between them, use <code>string join</code>.
      For example,<br>
      <code>set dateStr (string join '/' $month $day $year) # 8/26/2017</code>
    </div>
    <div>
      Another example is getting initials from a full name.
      Note how <code>string sub</code> can be used to get
      substrings from multiple strings in one call.
      Also note how the delimiter passed to <code>string join</code>
      can be an empty string.
    </div>
    <pre>
      set initialList (string sub -l 1 $first $middle $last) # R M V
      set initials (string join '' $initialList) # RMV</pre>
    <div>
      To create a string that repeats a given string,
      use <code>string repeat</code> with the
      <code>--count</code> (<code>-n</code>) switch
      For example,<br>
      <code>set newText (string repeat -n3 'foo') # foofoofoo</code>
    </div>

    <h3><a name="RegularExpressions">Regular Expressions</a></h3>
    <div>
      To determine if a string matches a "pattern",
      use the <code>string match</code> subcommand.
      By default this just compares one string to another
      for an exact match which isn't very useful.
    </div>
    <div>
      A more common use it to match against a regular expression
      by adding the <code>--regex</code> (<code>-r</code>) switch.
      This uses Perl regular expression syntax.
      By default only the first match is output,
      or nothing if not found.
      This sets status to 0 if at least one match was found and 1 if not.
      To suppress output describing the matches,
      add the <code>--quiet</code> (<code>-q</code>) switch.
    </div>
    <div>
      For example,
    </div>
    <pre>
set name 'Mark Volkmann'
string match --quiet --regex 'Vo' $name
echo $status # 0 for found
    </pre>
    <div>
      To output all matches, add the
      <code>--all</code> (<code>-a</code>) switch.
    </div>
    <div>
      To make matching case-insenstive,
      add the <code>--ingore-case</code> (<code>-i</code>) switch.
    </div>
    <div>
      To get indexes and lengths of matches instead of matching text,
      add the <code>--index</code> (<code>-n</code>) switch.
      This outputs an alternating list of indexes and lengths.
    </div>
    <div>
      Regular expressions can use capture groups.
      In this case, <code>string match</code> outputs a list containing
      each full match followed by the corresponding capture match.
    </div>
    <div>
      Here are several examples of using <code>string match</code>
      with regular expressions:
    </div>
    <pre>
set text 'This is foolish work for a boolean.'
set matches (string match -ar '.oo' $text) # foo boo
set matches (string match -anr '.oo' $text) # 9 3 28 3
set text 'A foal isn\'t boolean.'
set matches (string match -ar '.(o.).' $text) # foal oa bool oo</pre>

    <div>
      To determine if a string doesn't match,
      add the <code>--invert</code> (<code>-v</code>) switch.
    </div>
    <div>
      To replace text in a string with other text,
      use <code>string replace</code>.
      This is similar to <code>string match</code>
      It can match against literal text,
      or a regex using the <code>--regex</code> (<code>-r</code>) switch.
      When using a regex, it can utilize capture groups.
      For example, to replace all occurrences of "foo" with "bar",
    </div>
    <pre>
set text 'This is foolish work for a fool.'
set newText (string replace -a 'foo' 'bar' $text) # not using a regex
# this is barlish work for a barl
set newText (string replace -ar '.oo' 'bar' $text) # regex matching more than foo
# this is barlish work for a barl</pre>

    <h3><a name="Numbers">Numbers</a></h3>
    <div>
      Only integers are supported, not floating point.
      When a variable is set to a number, it is stored as a string.
    </div>
    <div>
      For example, if <code>set score 12345</code> is entered,
      the variable <code>score</code> will be set to a string containing
      the five characters "12345".
    </div>
    <div>
      To test the relationship between two numbers,
      use the <code>test</code> command.
      This supports many switches for various comparisons.
      Both operands must be numbers or
      strings that only contain digits which will be
      converted to numbers for the comparison.
    </div>
    <ul>
      <li>equal: <code>if test $n1 -eq $n2</code></li>
      <li>not equal: <code>if test $n1 -ne $n2</code></li>
      <li>less than: <code>if test $n1 -lt $n2</code></li>
      <li>less than or equal: <code>if test $n1 -le $n2</code></li>
      <li>greater than: <code>if test $n1 -gt $n2</code></li>
      <li>greater than or equal: <code>if test $n1 -ge $n2</code></li>
    </ul>

    <h3><a name="Math">Math</a></h3>
    <div>
      The <code>math</code> command is a wrapper around the
      <code>bc</code> command which is an abbreviation
      for "basic calculator".
      It allows an expression to be specified as an argument instead of
      reading from a file or piping in through stdin
      as is required with <code>bc</code>.
      The result is written to stdout.
      It sets status to a non-zero number if expression is invalid.
    </div>
    <div>
      Unlike the fish shell itself,
      this command supports floating point numbers.
    </div>
    <div>
      For information on available operators and functions,
      enter <code>man bc</code>.
    </div>
    <div>
      The <code>math</code> command accepts any number of arguments
      that are concatenated to form the expression
      that will be parsed by the <code>bc</code> command.
      It is only necessary to surround the expression in quotes
      if it contains characters that the shell would interpret specially.
      However, since these characters include
      <code>*</code> (for multiplication) and parentheses,
      quotes are often required.
    </div>
    <div>
      By default, the division and modulo operators
      output an integer result obtained by
      truncting the decimal portion (not rounding)
      even if all operands are floating point numbers.
      To include decimal places in the result,
      add the <code>-s</code> switch followed by
      a number of decimal points with no space after <code>-s</code>.
      For example, <code>math '2 / 3'</code> outputs <code>0</code>,
      but <code>math -s3 '2 / 3'</code> outputs <code>.666</code>.
      Note how this does not perform rounding at the last decimal place.
      As a consequence of this, <code>math -s0 '2 / 3'</code>
      outputs <code>0</code>, not <code>1</code>.
    </div>
    <div>
      The easiest way to get rounding is to use <code>printf</code>.
      For example, to round at three decimal places,
      <code>printf '%.3f' (math -s4 '2 / 3')</code> which outputs 0.667.
      Note how this requests one more decimal place from <code>math</code>
      that is requested from <code>printf</code>.
    </div>
    <div>
      Here is an example that utilizes variables.
    </div>
    <pre>
set width 2
set height 3
set area (math "$width * $height") # 6</pre>
    <div>
      The <code>bc</code> command supports functions
      from the Unix standard math library
      if the <code>--mathlib</code> (<code>-l</code>) switch is added.
      These functions include sine (s), cosine (c), arctangent (a),
      natural logarithm (l), exponentiation (e), and bessel (j).
      Unfortunately the <code>math</code> command doesn't support
      the <code>--mathlibl</code> switch, so it cannot use these functions.
      However, the <code>bc</code> command can be used directly in fish.
      Here's an example that determines the sine of 45 degrees.
    </div>
    <pre>
set pi (echo "a(1) * 4" | bc -l) # 3.14159265
set degrees 45
set radians (math -s8 "$degrees * $pi / 180") # .78539816
set result (echo "s($radians)" | bc --mathlib) # .70710678</pre>

    <h3><a name="Dates">Dates</a></h3>
    <div>
      The <code>date</code> command outputs the current date.
      The default format looks like "Sat Aug 26 16:54:52 CDT 2017".
      To use a different format, specify it using a format string
      as defined by the <code>strftime</code> command.
      For details, enter <code>man strftime</code>.
    </div>
    <div>
      For example, to format the date as "Saturday August 26, 2017"
      enter <code>date '+%A %B %d, %G'</code>.
      To format it as "08/26/2017"
      enter <code>date '+%m/%d/%G'</code>.
    </div>

    <h3><a name="Lists">Lists (a.k.a Arrays)</a></h3>
    <div>
      Recall that the value of all variables is a list which
      may contain any number of items, including none or just one.
      Lists contain string values.
      They cannot contain other lists.
    </div>
    <div>
      To create an empty list,
      enter <code>set <i>name</i></code>
    </div>
    <div>
      To create a non-empty list,
      enter <code>set <i>name</i> <i>item1</i> <i>item2</i> ...</code>
    </div>
    <div>
      For example, <code>set colors red green blue</code>
      is equivalent to <code>set colors 'red' 'green' 'blue'</code>.
      Neither of these is equivalent to <code>set colors 'red green blue'</code>
      in which the value of <code>colors</code> is set to a single string.
    </div>
    <div>
      To get the length of a list, use
      <code>count $<i>name</i></code>
    </div>
    <div>
      To append an item to a list, enter
      <code>set <i>name</i> $<i>name</i> <i>newItem</i></code>
    </div>
    <div>
      To prepend an item to a list, enter
      <code>set <i>name</i> <i>newItem</i> $<i>name</i></code>
    </div>
    <div>
      To get an item from a list by index,
      use <code><i>$name</i>[<i>index</i>]</code>.
      Indexes start at 1, not 0.
      Use negative indexes to retrieve from the end of a list.
      For example, <code><i>$name</i>[-1]</code> gets the last item.
    </div>
    <div>
      To set a list item by index,
      <code>set <i>name</i>[<i>index</i>] <i>value</i></code>
    </div>
    <div>
      To get a slice which is a new list, use
      <code>$<i>name</i>[<i>start</i>..<i>end</i>]</code><br>
      <code><i>start</i></code> and <code><i>end</i></code>
      can be positive or negative.
    </div>
    <div>
      To create a reversed version of an existing list, use
      <code>set <i>newName</i> <i>existingName</i>[-1..1]</code>
    </div>
    <div>
      To test whether an item is in a list, use<br>
<pre>
if contains <i>item</i> $<i>name</i>
  # code goes here
end</pre>
    <div>
      The <code>contains</code> command sets <code>status</code>
      to 0 if found and 1 if not.
    </div>
    <div>
      To get the index of an item in a list, use<br>
      <code>contains --index <i>item</i> $<i>name</i></code> (<code>-i</code>)
    </div>
    <div>
      To remove an item from a list, use
    </div>
<pre>
if set --local index (contains -i <i>item</i> $<i>name</i>)
  set --erase <i>name</i>[$index]
end</pre>
    <div>
      To iterate over all the items in a list, use
<pre>
for <i>item</i> in $<i>name</i>
  # use $<i>item</i> here
end</pre>
    </div>
    <div>
      Adjacent lists result in cartesian products.
      For example,
    </div>
<pre>
set columns a b c
set rows 1 2
set cells $columns$rows # a1 b1 c1 a2 b2 c2
count $cells # 6

set dashedCells $columns'-'$rows # a-1 b-1 c-1 a-2 b-2 c-2

set labels 'Column '$columns # Column a Column b Column c
count $labels # 3

set cells {a,b,c}{1,2} # a1 b1 c1 a2 b2 c2</pre>
    <div>
      Note that spaces cannot appear around the commas
      in the last example.
    </div>
    <div>
      When a fish shell is started,
      if the variables <code>PATH</code>, <code>CDPATH</code>, or <code>MANPATH</code> exist,
      they are converted to lists by splitting on colons.
    </div>

    <h3><a name="Eval">Eval</a></h3>
    <div>
      The <code>eval</code> command evaluates a command in a string
      that can be built using concatention and variable substitution.
      For example,
    </div>
    <pre>
set extension '.js'
set command ls *.$extension
eval $command</pre>

    <h3><a name="Hashmaps">Hashmaps</a></h3>
    <div>
      Hashmaps are not currently supported, but have been discussed at
      <a href="https://github.com/fish-shell/fish-shell/issues/390">https://github.com/fish-shell/fish-shell/issues/390</a>.
      They will be added in fish 3.
    </div>
    <div>
      Hashmaps can simulated with plain variables,
      but there isn't a way to iterate over the keys
      unless they are held in a list.
      For example,
    </div>
    <pre>
set colors red green blue
set items_red fire
set items_green grass
set items_blue water
for color in $colors
  eval echo '$'items_$color # fire, grass, water
end</pre>
    <div>
      Without the use of <code>eval</code> above, this would output
      <code>$items_red</code>, <code>$items_green</code>, and <code>$items_blue</code>.
    </div>

    <h3><a name="PATH">PATH environment variable</a></h3>
    <div>
      <code>PATH</code> is a variable that holds a lists of paths
      that the shell searches when a command is entered.
      <code>PATH</code> is a global variable, which means that
      changes to it are available anywhere in the current session,
      but not in others.
      Its value is not a colon-separated string like in other shells.
      It is a list created from a space-separated string.
    </div>
    <div>
      Typical PATH is defined in <code>config.fish</code>.
    </div>
    <div>
      To see the current value, enter <code>echo $PATH</code>.
    </div>
    <div>
      The universal variable <code>fish_user_paths</code>
      is another list of paths that is
      automatically prepended to <code>PATH</code>.
      Setting this modifies <code>PATH</code> in a way that
      affects all current and future sessions
      without having to modify <code>config.fish</code>
      and source it again.
      However, a benefit of changing PATH in <code>config.fish</code>
      is that the file can easily be copied to other machines.
    </div>
    <div>
      <code>fish_user_paths</code> should only be set in a terminal,
      not in <code>config.fish</code>.
    </div>
    <div>
      To prepend a path to PATH,<br>
      <code>set -U fish_user_paths $fish_user_paths <i>new-path</i></code><br>
      This outputs a warning if no directory matching <code><i>new-path</i></code>
      is found, but adds it anyway.
    </div>
    <div>
      As we will see later, all variables hold a list.
      It's just that many of them only contain a single value.
      Removing a path from PATH or fish_user_paths is done
      the same way as removing an item from any list.
    </div>
    <div>
      To remove a path from fish_user_paths:
    </div>
    <pre>
if set -l index (contains -i <i>some-path</i> $fish_user_paths)
  set -e fish_user_paths[$index]
end</pre>

    <h3><a name="FunctionsAndAutoLoading">Functions and Auto-loading</a></h3>
    <div>
      Every time a command is evaluated, fish first checks whether there
      is a file in any path listed in <code>fish_function_path</code>
      with the same name and a <code>.fish</code> extension.
      This path list typically contains <code>~/.config/fish/functions</code>
      which is where user-defined functions are usually placed.
      It does not search subdirectories of these paths.
      If a matching file is found, and the file has not been loaded
      within the "staleness interval" (discussed later),
      it loads the file to get the current definition of the function
      and executes the function.
      This is referred to as "auto-loading".
    </div>
    <div>
      Functions defined in these paths
      are immediately available in all fish shells.
      Changes to them are automatically reloaded in all fish shells
      the next time they are used.
    </div>
    <div>
      If no such function is found, fish then checks whether there is
      an executable file in any path listed in <code>PATH</code>
      with the same name.  If so, that file is executed.
    </div>
    <div>
      Function auto-loading allows functions to be used in place of
      commands, builtins, and executables in <code>PATH</code>.
      For example, the <code>date</code> command can be overridden
      with a custom function by entering
      <code>function date; echo pwned date; end</code>.
      After this, entering <code>date</code> outputs "pwned date"
      instead of the output of the <code>date</code> command
      in the current fish session.
      To affect all fish sessions, enter <code>funcsave date</code>.
    </div>
    <div>
      The staleness interval avoids thrashing the file system
      every time a command is evaluated, and is around five seconds.
      To use a modified function definition before the
      staleness interval passes, source the file.  For example,
    </div>
    <pre>
funced foo; and funcsave foo; and source ~/.config/fish/functions/foo.fish</pre>
    <div>
      The <code>funced</code> and <code>funcsave</code> commands
      are described later.
    </div>
    <div>
      It is recommended that these files only define
      the function whose name matches the command.
    </div>
    <div>
      It is possible to have a function, builtin, and command
      that all have the same name.
      Functions take precedence over builtins
      and builtins take precedence over commands.
      To run a function, just enter its name.
      To run a builtin instead of a function with the same name,
      enter <code>builtin <i>name</i></code>.
      To run a command instead of a function or builtin with the same name,
      enter <code>command <i>name</i></code>.
    </div>

    <h2><a name="ScriptingInFish">Scripting in Fish</a></h2>

    <div>
      If you appreciate programming languages with simple, consistent syntax,
      you will love scripting in fish!
    </div>
    <div>
      Scripts are implementing by writing a function.
      Functions become custom commands that can be executed from a terminal.
      A function is defined by using the <code>function</code> command.
      Functions can have named parameters.
      Functions cannot return a value,
      but they can write to a stream like stdout and stderr and
      they can return a status that goes into the variable <code>status</code>.
      When a function is called, whatever it writes to stdout
      can be captured in a variable with
      <code>set myVar (myFunction args)</code>.
      Parentheses can also be used to pass the output of a command
      as an argument to another command.
    </div>
    <div>
      In other shells, many steps are required to write and enable a new script.
    </div>
    <ul>
      <li>Decide where to create the implementation file.</li>
      <li>Make sure the directory is listed in the PATH environment variable.</li>
      <li>Create the file and write the code.</li>
      <li>Add a "shebang" comment as the first line.</li>
      <li>Use the <code>chmod</code> command to make the file executable.</li>
    </ul>
    <div>
      While the same can be done with fish scripts,
      most of these steps are not necessary.
      The easiest way to write and enable a new fish script is:
    </div>
    <ul>
      <li>
        Enter <code>funced <i>name</i></code>.
        This opens an editor for entering or modifying the script.
        If the script is new, the editor is populated with
        a starting point for a function definition.
      </li>
      <li>
        Write or modify the code, save the changes, and exit the editor.
        If the function was previously defined in a file,
        this will not update the file!
      </li>
      <li>
        Enter <code>funcsave <i>name</i></code>.
        This saves the script to a file with the same name as the function
        in the <code>~/.config/fish/functions</code> directory.
        When commands are executed, fish automatically looks
        for their implementation here.
        If this step is skipped, the function can still be used as a command,
        but it won't be available in other existing or future sessions.
      </li>
    </ul>

    <h3><a name="ComparingToJavaScript">Comparing fish functions to JavaScript</a></h3>
    <div>
      Let's look at an example of a simple function that
      takes two numbers and outputs their product.
      It's useful to see how fish functions differ from
      functions in more traditional programming languages like JavaScript.
    </div>
    <div>
      Here is the function in JavaScript and a call to it.
    </div>
    <pre>
function product(n1, n2) {
  return n1 * n2;
}
const result = product(2, 3); // 6</pre>
    <div>
      Here is the function in fish and a call to it.
    </div>
    <pre>
function product -a n1 n2
  math "$n1 * $n2"
end
set result (product 2 3) # 6</pre>
    <div>
      Everthing in fish is done with commands, even defining functions.
      The <code>--argument-names</code> (<code>-a</code>) switch of the
      <code>function</code> command specifies named parameters.
      Recall that functions in fish cannot return a value,
      but they can write to streams like stdout.
      Math is performed using the <code>math</code> function
      which writes its result to stdout.
      Surrounding a command with parens allows its stdout to be
      captured and placed in a variable.
    </div>

    <h3><a name="ToolsForFish">Tools for fish</a></h3>
    <div>
      Here's a list of popular tools for fish in alphabetical order.
    </div>
    <ul>
      <li>Fisherman -
        "The fish-shell plugin manager"<br>
        <a href="https://github.com/fisherman/fisherman">https://github.com/fisherman/fisherman</a>
      </li>
      <li>Fundle -
        "a minimalist package manager for fish inspired by Vundle"<br>
        <a href="https://github.com/tuvistavie/fundle">https://github.com/tuvistavie/fundle</a>
      </li>
      <li>Oh My Fish -
        "provides core infrastructure to allow you to install packages
        which extend or modify the look of your shell"<br>
        <a href="https://github.com/oh-my-fish/oh-my-fish">https://github.com/oh-my-fish/oh-my-fish</a>
      </li>
      <li>Tacklebox -
        "makes it easy to organize and share collections of
        useful shell functions, tools, and themes"<br>
        <a href="https://github.com/justinmayer/tacklebox">https://github.com/justinmayer/tacklebox</a>
      </li>
    </ul>

    <h3><a name="echoCommand">echo Command</a></h3>
    <div>
      The <code>echo</code> command writes its expanded arguments to stdout.
      Normally all arguments are output with a space between them.
      To suppress this, add the <code>-s</code> switch (no long form).
      To suppress the newline that is normally output at the end,
      add the <code>-n</code> switch (no long form).
      To make a sound ("beep"), output the <code>\a</code> character.
    </div>

    <h3><a name="Colors">Colors</a></h3>
    <div>
      By default when entering commands,
      text is red until a valid command is entered
      and then it changes to "normal"
      which is the configurble, default, foreground color.
      When typing file paths, the text is underlined
      unless no directory or file matches what has been typed so far.
    </div>
    <div>
      The color of output can be customized
      using the <code>set_color</code> command.
      This command outputs a sequence of characters that changes
      the foreground color for subsequently output text.
    </div>
<pre>
echo Roses are (set_color red)red(set_color normal), \
  violets are (set_color blue)blue(set_color normal).</pre>
    <div>
      The characters output by the <code>set_color</code> command
      can be captured in a variable and output later.
      For example,
      <code>set makeBlue (set_color blue); echo 'I am '$makeBlue'blue'</code>
    </div>
    <div>
      Colors can be specified by using a color name or value.
      The supported color names include
      black, red, green, yellow, blue, magenta, cyan, and white.
      There are also bright versions of these where "br"
      is prepended to the name, for example, brblue.
      Color values are specified with three or six hex characters.
      For example, <code>f0f</code> is full red, no green, and full blue
      which is between magenta and brmagenta.
    </div>
    <div>
      The <code>set_color</code> command supports many switches.
    </div>
    <ul>
      <li><code>--background</code> (<code>-b</code>) to specify a background instead of a foreground color</li>
      <li><code>--print-colors</code> (<code>-c</code>) prints the list of supported color names</li>
      <li><code>--bold</code> (<code>-o</code>) sets bold mode</li>
      <li><code>--dim</code> (<code>-d</code>) sets dim mode<br>
        Some terminals, including iTerm2 on macOS, don't support this by default.</li>
      <li><code>--italics</code> (<code>-i</code>) sets italics mode<br>
        Some terminals, including iTerm2 on macOS, don't support this by default.</li>
      <li><code>--reverse</code> (<code>-r</code>) sets reverse mode</li>
      <li><code>--underline</code> (<code>-u</code>) sets underlined mode</li>
    </ul>
    <div>
      To enable the use of <code>--dim</code> and <code>--italics</code>
      on macOS in iTerm2, vim, and tmux, see
      <a href="https://alexpearce.me/2014/05/italics-in-iterm2-vim-tmux/">https://alexpearce.me/2014/05/italics-in-iterm2-vim-tmux/</a>,
      the answer from Ian Edington at
      <a href="https://apple.stackexchange.com/questions/249307/tic-doesnt-read-from-stdin-and-segfaults-when-adding-terminfo-to-support-italic/295584#295584">https://apple.stackexchange.com/questions/249307/tic-doesnt-read-from-stdin-and-segfaults-when-adding-terminfo-to-support-italic/295584#295584</a>,
      and the Vim-specific information at
      <a href="https://stackoverflow.com/questions/3494435/vimrc-make-comments-italic">https://stackoverflow.com/questions/3494435/vimrc-make-comments-italic</a>.
      Also see my <code>.terminfo</code> files at
      <a href="https://github.com/mvolkmann/MyUnixEnv">https://github.com/mvolkmann/MyUnixEnv</a>
      and the <code>setup</code> script there that
      runs the <code>tic</code> command on the <code>.terminfo</code> files.
    </div>
    <div>
      Using <code>set_color</code> without these switches resets to default mode.
    </div>
    <div>
      To reset all colors and switches, use <code>set_color normal</code>.
      Typically this is close to white or black, but it is configurable.
      When commands are entered in a shell,
      the color of their output is automatically reset to normal
      after each line is entered.
      The color is not automatically reset inside a function.
    </div>
    <div>
      There are many universal variables whose names begin with
      <code>fish_color_</code> or <code>fish_pager_color_</code>
      that control colors of various syntax elements.
      These variables can be modified to customize the colors.
    </div>
    <div>
      For another example of using the <code>set_color</code> command,
      see the custom prompt defined in the file <code>fish_prompt.fish</code>
      in the "Custom Prompt" section.
    </div>

    <h3><a name="printfCommand">printf Command</a></h3>
    <div>
      The <code>printf</code> command writes to stdout using a format string.
      It takes a format string as its first argument,
      followed by the values to be output.
    </div>
    <div>
      The format string can contain a format specifier
      for each of the values to be output.
      The supported format specifiers include:
    </div>
    <ul>
      <li><code>%d</code> or <code>%i</code> for signed decimal (integer)</li>
      <li><code>%f</code> for float</li>
      <li><code>%s</code> for string</li>
      <li><code>%%</code> for literal %</li>
      <li>and more</li>
    </ul>
    <div>
      The <code>printf</code> command supports several escape characters
      that include:
    </div>
    <ul>
      <li><code>\a</code> for bell</li>
      <li><code>\n</code> for newline</li>
      <li><code>\t</code> for tab</li>
      <li>and more</li>
    </ul>
    <div>
      Here are some examples of using the <code>printf</code> command.
    </div>
<pre>
set format 'My name is %s and I am '(set_color red)%i(set_color normal)' years old.'
printf $format Paige 6

set format 'My name is %s and I am %s%i%s years old.'
printf $format Paige (set_color red) 6 (set_color normal)
</pre>

    <h3><a name="Wildcards">Wildcards</a></h3>
    <div>
      <code>?</code> matches a single character.<br>
      <code>*</code> matches any number of characters not containing <code>/</code>.<br>
      <code>**</code> is like <code>*</code>, but also matches <code>/</code>.
      This enables recursing into subdirectories.
    </div>

    <h3><a name="PipesAndRedirection">Pipes and Redirection</a></h3>
    <div>
      To "pipe" the stdout of one command into the stdin of another,
      use <code>|</code> like other shells.
      For example, <code>echo '<i>some input</i>' | <i>someCommand</i></code>.
    </div>
    <div>
      For commands that read from stdin, to read from a file instead,
      use <code>&lt;</code> like in other shells.
      For example, <code><i>someCommand</i> &lt; <i>someFilePath</i></code>.
    </div>
    <div>
      For commands that write to stdout, to write to a file instead,
      use <code>&gt;</code> like in other shells.
      For example, <code><i>someCommand</i> &gt; <i>someFilePath</i></code>.
      To avoid overwriting an existing file, use <code>&gt;?</code> instead of <code>&gt;</code>.
      To append to an existing file, use <code>&gt;&gt;</code> instead of <code>&gt;</code>.
    </div>
    <div>
      For commands that write to stderr, to write to a file instead
      use <code>^</code> unlike other shells that use <code>2></code>.
      For example, <code><i>someCommand</i> ^ <i>someFilePath</i></code>.
      For compatibility with other shells, <code>2></code> can also be used.
      To avoid overwriting an existing file, use <code>^?</code> instead of <code>^</code>.
      To append to an existing file, use <code>^^</code> instead of <code>^</code>.
    </div>
    <div>
      To redirect stderr to stdout, use <code><i>someCommand</i> 2&gt;&amp;1</code>.
    </div>

    <h3><a name="AdvancedUseOfVariables">Advanced Use of Variables</a></h3>
    <div>
      Multiple <code>$</code>'s can be used to interpret the value of a variable
      as a variable name.  Consider the following examples:
    </div>
    <pre>
set foo 1
set bar foo
echo $$bar # 1

set pocket 'wallet'
set pant pocket
echo $$pant # wallet

set foreground blue
set background green
set side fore
set name "$side"ground
echo $$name # blue</pre>
    <div>
      From
      <a href="https://fishshell.com/docs/current/index.html#expand-variable">https://fishshell.com/docs/current/index.html#expand-variable</a>,
      "When using this feature together with array brackets,
      the brackets will always match the innermost $ dereference."
      To understand this, consider the following example.
    </div>
    <pre>
set colors red green blue
set listName colors</pre>
    <div>
      How can we write code to get the value "green"
      from the list of colors?
    </div>
    <div>
      <code>echo $$listName[2]</code>
      doesn't work because it evaluates like
      <code>tmp = $listName[2]</code>
      and then <code>$tmp</code> on that.
      <code>$listName[2]</code> gives array index out of bounds
      because the value of <code>$listName</code> is just
      <code>'colors'</code> and that has no value at index 2.
    </div>
    <div>
      <code>echo $$listName[1][2]</code> works!
      <code>$$listName[1][2]</code> evaluates like
      <code>$listName[1]</code> which gives <code>'colors'</code>
      and then <code>$colors[2]</code> which gives <code>'green'</code>.
    </div>

    <h3><a name="SpecialVariables">Special Variables</a></h3>
    <div>
      There are many global variables that are automatically set
      to various values.  Examples include:
    </div>
    <ul>
      <li><code>CMD_DURATION</code> - duration of the last command in milliseconds</li>
      <li><code>COLUMNS</code> - number of columns in the current terminal</li>
      <li><code>FISH_VERSION</code> and <code>version</code>
        - version of the fish shell being used<br>
        (can be output by entering <code>fish -v</code>)</li>
      <li><code>HOME</code> - user's home directory</li>
      <li><code>LINES</code> - number of lines (or rows) in the current terminal</li>
      <li><code>PWD</code> - current (or present) working directory</li>
      <li><code>USER</code> - current username</li>
      <li><code>_</code> - name of the currently executing command</li>
      <li><code>status</code> - status of the last command</li>
    </ul>
    <div>
      Variables whose names begin with <code>__fish</code>
      are for internal use and should not be used or changed.
    </div>

    <h3><a name="statusCommand">status Command</a></h3>
    <div>
      The <code>status</code> command has many subcommands.
      Examples that are useful inside functions include:
    </div>
    <ul>
      <li><code>status current-filename</code> -
        outputs file path of current file<br>
        If the function was defined interactively
        and has not been explicitly saved to a file,
        this will output the path to the temporary file
        where its definition has been saved.</li>
      <li><code>status current-function</code> -
        outputs name of current function</li>
      <li><code>status current-line-number</code> -
        outputs the line number within the file where this appears.
        This command has issues.  See
        <a href="https://github.com/fish-shell/fish-shell/issues/4161">https://github.com/fish-shell/fish-shell/issues/4161</a>.
      </li>
      <li><code>status print-stack-trace</code> -
        prints a stack trace which is useful for debugging issues
        in nested function calls</li>
    </ul>

    <h3><a name="MoreOnTests">More on Tests</a></h3>
    <div>
      The <code>test</code> command is commonly used in
      <code>if</code> and <code>while</code> commands.
      Tests for strings, numbers, and files are
      described in those sections of this article.
      For example, <code>test $color = 'yellow'</code>.
    </div>
    <div>
      To negate any test, add <code>!</code> after <code>test</code>
      and before the expression being tested.
      For example, <code>test ! $color = 'yellow'</code>.
      This call also be written as <code>test $color != 'yellow'</code>.
    </div>
    <div>
      There are two ways to combine conditions.
      The first option is to use the
      <code>and</code> and <code>or</code> commands.
      For example,
    </div>
    <pre>
if test $color = 'yellow'; and test $size = 'large'
  # code here
end</pre>.
    <div>
      This can also be written on two lines
      by replacing the semicolon with a newline as follows.
    </div>
    <pre>
if test $color = 'yellow'
  and test $size = 'large'
  # code here
end</pre>
    <div>
      The second option is to place <code>-a</code> or <code>-o</code>
      between the conditions.  For example,
    </div>
    <pre>
if test \( $color = 'yellow' \) -a \( $size = 'large' \)
  # code here
end</pre>
    <div>
      But this option requires parentheses and those must be escaped
      which results in some ugly code, so the first option is preferred.
    </div>

    <h3><a name="Files">Files</a></h3>
    <div>
      To open files using their default applications,
      enter <code>open <i>filePath1</i> <i>filePath2</i> ...</code>.
      For example, <code>open demo.html</code>
      opens the file in the default web browser.
    </div>
    <div>
      To iterate over the lines in a text file,
      redirect a file into a loop as follows:
    </div>
    <pre>
while read line
  # do something with $line
end &lt; <i>filePath</i> </pre>
    <div>
      To test various characteristics of a file,
      assuming <code>file</code> is a variable that holds a file path,
    </div>
    <ul>
      <li>exists: <code>if test -e $<i>file</i></code></li>
      <li>is a file: <code>if test -f $<i>file</i></code></li>
      <li>is a directory: <code>if test -d $<i>file</i></code></li>
      <li>is a symbolic link: <code>if test -L $<i>file</i></code></li>
      <li>is readable: <code>if test -r $<i>file</i></code></li>
      <li>is writable: <code>if test -w $<i>file</i></code></li>
      <li>is an executable file: <code>if test -x $<i>file</i></code></li>
      <li>is a non-empty file (has size): <code>if test -s $<i>file</i></code></li>
      <li>and more (see test command for details)</li>
    </ul>
    <div>
      The <code>test</code> command does not support
      long forms of switches used above.
    </div>

    <h3><a name="CommandSubstitution">Command Substitution</a></h3>
    <div>
      To use the output of one command as an argument to another,
      surround the command with parens,
      not backticks like in some other shells.
    </div>
    <div>
      If the command outputs more than one line,
      each will be treated as a separate argument
      to the outer command.
    </div>
    <div>
      To set a variable to the output of a command,
      use <code>set <i>name</i> (<i>command</i>)</code>.
      For example, <code>set today (date)</code>.
    </div>
    <div>
      Command output can be concatenated with literal strings
      and other command output.  For example,
    </div>
    <pre>
set dateFormat '+%A %B %d, %G' # ex. Tuesday, August 15, 2017
set announcement 'Today is '(date $dateFormat)'.'</pre>
    <div>
      Note the use of string concatention by placing
      literal strings next to the parens.
    </div>
    <div>
      This does not work inside strings.
      For example, the command in the following string is not evaluated:
      <code>"Today is (date $dateFormat)."</code>
    </div>

    <h3><a name="BraceExpansion">Brace Expansion</a></h3>
    <div>
      Brace expansion is used to produce multiple arguments for a command.
      For example, <code>ls *.{css,html.js}</code>
      expands to <code>ls *.css *.html *.js</code>.
      This is also useful in the <code>cp</code> and <code>mv</code> commands.
    </div>

    <h3><a name="Functions">Functions</a></h3>
    <div>
      Functions give a name to a set of commands that
      are executed when the function is invoked.
      Functions can become available to execute as commands
      when their name is used as a command in a shell.
      In that case they can override
      commands from <code>PATH</code> and builtin commands.
    </div>
    <div>
      To call a function, specify its name optionally followed by arguments.
      No parentheses are used around arguments and no commas are used between them.
    </div>
    <div>
      Functions cannot return a value,
      but they can set the status variable
      and they can write to streams like stdout and stderr.
      To capture stdout from a function in a variable, use
      <code>set <i>variable</i> (<i>someFn</i> <i>args</i>)</code>.
      For example:
    </div>
    <pre>
function product -a n1 n2
  echo (math "$n1 * $n2")
end
set result (product 3 4) # 12</pre>
    <div>
      Function names cannot begin with a dash (<code>-</code>),
      but they can begin with any other character, even digits.
      Function names cannot contain a slash (<code>/</code>),
      but they can contain any other character, even spaces.
      To include a space, prefix it with <code>\</code>.
      For example, <code>function foo\ bar; echo in foo bar; end</code>
      To call this function, use <code>foo\ bar</code>.
      While this is supported, doing this seems like a bad idea.
    </div>
    <div>
      Functions can be defined interactively
      using the <code>function</code> command.
      This continues reading from stdin
      until a corresponding <code>end</code> command is entered.
      For example,
    </div>
    <pre>
function <i>name</i>
  # code goes here
end</pre>
    <div>
      Many switches can follow the function name.
      Some are described later.
      To add documentation, use <code>--description '<i>some desc</i>'</code>
      (<code>-d</code>).
      To display the description of a function, enter
      <code>functions --details --verbose <i>fnName</i> </code>
      and note the fifth line of the output.
      The <code>--details</code> switch is described further below.
    </div>
    <div>
      Here is a function that can be used to
      only output the description of another function:
    </div>
    <pre>
function fndesc -a fnName -d 'displays description of a function'
  set lines (functions -Dv $fnName)
  echo $lines[5]
end</pre>
    <div>
       All functions are public.
       Prefixes can be used to denote "private" functions
       and to avoid name conflicts.
       For example, <code>_<i>somePrefix</i> </code>.
    </div>
    <div>
      The most common way to make functions available in future sessions
      is to define them in files
      under the <code>~/.config/fish/functions</code> directory
      (not in subdirectories of this directory).
      There is no need to mark these files as executable.
      There no need to modify PATH because by default this directory is included.
      This is no need to add a "shebang comment" in these files.
      All functions defined here are assumed to be used only in the fish shell.
    </div>
    <div>
      These files are loaded the first time
      the function they define is called.
      The autoloading mechanism for functions requires the name
      of these files to match the name of function they define.
      TODO: See more in "Commands" section.
      For example, define the function foo in a file named <code>foo.fish</code>.
      Multiple functions can be defined in the same file,
      but they will not be available until the function
      whose name matches the file is called once,
      so doing this is not recommended.
    </div>
    <div>
      To save a function definition that has been entered interactively
      in a file in <code>~/.config/fish/functions</code>, enter
      <code>funcsave <i>name</i></code>.
      This uses tabs for indentation.
      Doing this allows the function to be autoloaded in all future sessions.
    </div>
    <div>
      To edit a function definition, enter <code>funced <i>name</i></code>.
      If the function is not already defined, it will be created.
      This uses the editor in the <code>VISUAL</code> variable
      that can be set in <code>config.fish</code>.
      It defaults to emacs, but can be changed to Vim with
      <code>set VISUAL vim</code>.
      This is more convenient that starting an editor first and then
      creating the file in the proper directory or locating it
      from within the editor.
      After every use of <code>funced</code>,
      if the changes should be available in other sessions,
      including both current and future sessions,
      run <code>funcsave <i>name</i></code>.
      This saves the changes in a <code>.fish</code> file
      under <code>~/.config/fish/functions</code>.
    </div>
    <div>
      To output a formatted version of a <code>.fish</code> file, enter
      <code>fish_indent &lt; <i>someName</i>.fish</code>.
      The fish_indent command writes to stdout.
      To output using the colors specified in <code>fish_config</code>,
      add the <code>--ansi</code> (no short form) switch.
      To output as HTML, add the <code>--html</code> (no short form) switch.
      With HTML it is possible to add colors to specific syntax items using CSS.
      To read from a file and rewrite it with a formatted version, enter
      <code>fish_indent --write <i>someName</i>.fish</code> (<code>-w</code>).
      This uses four-space indentation and that cannot be customized.
      However, all occurrences of four spaces can be replaced with two
      using the following command which also saves a backup of the original file
      in a new file with <code>.bak</code> appended to the name.
    </div>
    <pre>
sed -i .bak 's/    /  /g' <i>fn-name</i>.fish</pre>
    <div>
      To list all currently defined functions, enter <code>functions</code>.
      To include private fish functions whose names begin with a double underscore,
      add the <code>--all</code> (<code>-a</code>) switch.
      To view all currently defined functions in the web UI,
      enter <code>fish_config functions</code>.
    </div>
    <div>
      To output the code for one or more functions, enter
      <code>functions <i>name1</i> <i>name2</i> ...</code>.
    </div>
    <div>
      To output the path to where a function is defined, enter
      <code>functions --details <i>name</i></code> (<code>-D</code>).
      If the function has not been saved to a file, this will output "stdin".
    </div>
    <div>
      To see even more detail about a function, enter
      <code>functions --details --verbose <i>name</i></code> (<code>-Dv</code>).
      This outputs the following five lines:
    </div>
    <ul>
      <li>path to definition</li>
      <li>whether it was autoloaded (outputs "autoloaded" or "n/a")</li>
      <li>line number within file where definition begins or 0 if not autoloaded</li>
      <li>whether "scope shadowing" was disabled</li>
      <li>the function description specified with the
        <code>--description</code> or <code>-d</code> switch
        or "n/a" if no description was provided</li>
    </ul>

    <div>
      To copy a function definition to a new name, enter
      <code>functions --copy <i>oldName</i> <i>newName</i></code> (<code>-c</code>).
      This only copies the function body, not any switches specified in the definition.
    </div>
    <div>
      To delete (erase) a function, enter
      <code>functions --erase <i>name</i></code> (<code>-e</code>).
      If the function is defined in a file, this doesn't delete the file.
      It just makes the function inactive in the current session.
    </div>
    <div>
      To test if a function exists, enter
      <code>functions --query <i>name</i></code> (<code>-q</code>).
      This sets status to 0 if the function exists and 1 otherwise.
    </div>
    <div>
      The <code>return</code> command can be used in a function
      to exit before the end.
      This also sets the exit status of the function
      which defaults to 0 for success, but can be specified.
      For exammple, <code>return 2</code> exits the function
      in which it was executed and sets status to 2..
    </div>
    <div>
      The arguments specified in a function call
      are held in a list in the <code>argv</code> variable.
      The first argument can be accessed with <code>$argv[1]</code>.
      Iterating over the arguments is done in the same way as iterating over any list.
    </div>
    <div>
      Functions can also use named parameters.
      For example:
    </div>
    <pre>
function orderShirt -a color size
  # Use $color and $size here.
  # $argv is also set to a list of the arguments.
end</pre>
    <div>
      All named parameters will be "set",
      but ones not specified will be set to an empty list.
      To test whether a specific named parameter is set, use
      <code>set -q <i>argName</i>[1]</code>.
      To set a named parameter to a default value if it is not specified, use:
    </div>
    <pre>
set -q <i>argName</i>[1]; or set -l <i>argName</i> <i>defaultValue</i></pre>
    <div>
      To process command-line arguments to a function as switches (a.k.a. options):
    </div>
    <pre>
for option in $argv
  switch "$option"
    case -h --help
      # code here
    ...
    case '*'
      # code here
  end
end</pre>
    <div>
      The <code>switch</code> command is described later.
    </div>
    <div>
      Function do not have access to local variables set outside them.
      They are not closures like functions in programming languages like JavaScript.
    </div>
    <div>
      If a function needs to output an error message,
      a good approach is the following:
    </div>
    <pre>
set_color $fish_color_error
echo <i>someErrorMsg</i> 1&gt;&amp;2
set_color normal
return <i>someNonZeroStatus</i></pre>

    <h3><a name="AutoRunningFunctions">Auto-running Functions</a></h3>
    <div>
      Functions can run automatically when an event is fired.
      This is configured by adding the <code>--on-event</code> (<code>-e</code>)
      switch to a function definition.
      For example,
    </div>
    <pre>
function takeShelter --on-event tornado
  echo Tornado warning! Take shelter!
end</pre>
    <div>
      Functions that run when an event is fired are not auto-loaded.
      Consider defining them in <code>config.fish</code> or
      sourcing files that define them from <code>config.fish</code>.
      The command <code>source <i>filePath</i></code>
      executes commands in the file without starting a new process.
      Changes to variables made in this code affects the current shell.
    </div>
    <div>
      Any number of functions can be registered to run on the same event.
    </div>
    <div>
      Events can be emitted with <code>emit <i>eventName</i></code>.
      The event name can be any string.
      The event name can be followed by any number of arguments.
      These become the value of the <code>argv</code> list inside the function.
      For example, <code>emit tornado 'category 4' 12</code>.
    </div>
    <div>
      Events are only handled within the current process.
    </div>
    <div>
      The fish shell generates these events:
    </div>
    <ul>
      <li>
        <code>fish_prompt</code><br>
        This is emitted whenever a new fish prompt is about to be displayed.
      </li>
      <li>
        <code>fish_command_not_found</code><br>
        This is emitted whenever a command lookup fails.
        It is a bit like <code>method_missing</code> in the Ruby programming language.
      </li>
      <li>
        <code>fish_preexec</code><br>
        This is emitted before executing an interactive command,
        even if the command is invalid.
        The command line is passed as the first parameter.
      </li>
      <li>
        <code>fish_postexec</code><br>
        This is emitted after executing an interactive command,
        even if the command is invalid.
        The command line is passed as the first parameter.
      </li>
    </ul>
    <div>
      Functions can run automatically when a variable changes.
      This is configured by adding the <code>--on-variable</code> (<code>-v</code>)
      switch to a function definition.
      For example, the following function runs every time
      the PATH variable changes.
      It echoes the new value.
    </div>
    <pre>
function announcePath --on-variable PATH
  echo PATH is now $PATH
end
set -U PATH /foo $PATH</pre>
    <div>
      Since changing the variable <code>fish_user_paths</code>
      also changes <code>PATH</code>, that also triggers this function.
    </div>
    <div>
      Functions can run automatically when a given process exits.
      This is configured by adding the <code>--on-process-exit</code> (<code>-p</code>)
      switch to a function definition.
      For example,
    </div>
    <pre>
function announceProcessExit --on-process-exit 12345
  echo an important process exited
end

# %self expands to the current process id.
function announceMyExit --on-process-exit %self
  echo I exited
end</pre>
    <div>
      Function can run automatically when a specific signal is received.
      This is configured by adding the <code>--on-signal</code> (<code>-s</code>)
      switch followed by a signal name or number to a function definition.
      For a list of possible signals, enter <code>kill -l</code>.
      To see the keystrokes that generate some of these signals,
      enter <code>stty -a</code> and look for "cchars:".
      As an example, pressing ctrl-d sends an "eof" signal.
    </div>
    <div>
      To send any signal to a given process, enter
      <code>kill -<i>signalNameOrNumber</i> <i>pid</i></code>.
      For example, to handle a "hup" signal,
    </div>
    <pre>
function handleHupSignal --on-signal hup
  echo got hup
end

kill -hup %self # got hup</pre>
    <div>
      For more information on Unix signals, see
      <a href="https://www.tutorialspoint.com/unix/unix-signals-traps.htm">https://www.tutorialspoint.com/unix/unix-signals-traps.htm</a>.
    </div>

<h3><a name="TypesOfCommands">Types of Commands</a></h3>
    <div>
      A "command" is any program the shell can run.
      There are three types of commands: builtins, commands, and functions.
    </div>
    <div>
      "Builtins" are commands that are provided by the shell.
      Examples include <code>contains</code>, <code>echo</code>, and <code>if</code>.
      To get a list of builtin names, enter
      <code>builtin --names</code> (<code>-n</code>)
      The <code>builtin</code> command can also be used to
      execute a specific builtin instead of a
      command or function with the same name.
    </div>
    <div>
      "Commands" are executables found in <code>PATH</code>.
      Examples include <code>chmod</code>, <code>ls</code>,
      <code>node</code>, and <code>vim</code>.
      To get the path to a command, enter
      <code>command --search <i>name</i></code> (<code>-s</code>)
      or <code>which <i>name</i></code>.
      The <code>command</code> command followed by the name of a command
      can be used to execute a specific command instead of a
      builtin or function with the same name.
    </div>
    <div>
      "Functions" have two sources, those provided by fish
      and those that are user-defined.
      Examples of provided functions include
      <code>abbr</code>, <code>cd</code>, and <code>eval</code>.
      There are also many fish-specific functions
      whose names begin with <code>fish_</code>.
    </div>
    <div>
      User-defined functions can be defined in
      files with a <code>.fish</code> extension
      in any directory listed in the <code>fish_function_path</code> directory.
      By default, this includes the <code>~/.config/fish/functions</code> directory.
    </div>
    <div>
      For example,
    </div>
    <pre>
alias greet 'echo Hello, $USER'
functions greet
# This outputs the following:
# Defined in - @ line 0
function greet --description 'alias greet echo Hello, $USER'
  echo Hello, $USER $argv;
end</pre>
    <div>
      Note how within this function <code>$argv</code> is added
      to the end of the command specified in the alias.
      This allows additional switches and arguments to be
      passed to the command when the alias is used.
    </div>
    <div>
      To determine if a function is defined, enter
      <code>functions --query <i>name</i></code>.
      This sets status to 0 if defined or 1 if not.
    </div>
    <div>
      To get the type of a name, enter <code>type <i>name</i></code>.
      For a function, this outputs "<i>name</i> is a function with definition",
      followed by the definition.
      For a builtin, this outputs "<i>name</i> is a builtin".
      For a command, this outputs the path to the file that defines it.
      To get just the type, enter <code>type -t <i>name</i></code>.
      This outputs "function", "builtin", or "file" (for commands).
    </div>

    <h3><a name="ifCommand">if Command</a></h3>
    <div>
      The if command supports conditional logic.
      It's syntax is:
    </div>
    <pre>
if <i>command</i>
  <i>commands</i>
else if <code>command</code>
  <i>commands</i>
else
  <i>commands</i>
end</pre>
    <div>
      Note that <code>if</code> is followed by a fish command,
      not a "condition".
      The status of the command it used to determine
      whether the commands in that branch will be executed.
      A status of 0 is treated as success or true and
      any other value is treated as an error or false.
      This is opposite from most programming languages,
      but is standard in shells.
    </div>
    <div>
      A common command to use in an <code>if</code>
      is <code>test</code>.  For example,
      to explictly test the status of the
      last command executed before an <code>if</code>, use
      <code>if test $status # success</code> or
      <code>if test $status != 0 # failure</code>
    </div>
    <div>
      A command status can be negated using
      the <code>not</code> command.
      This command changes the status variable
      to 1 if it is currently 0, and 0 otherwise.
      For example,
      <code>if not test $status</code> or
      <code>if not <i>someCommand</i></code>.
    </div>
    <div>
      An <code>if</code> command can be specified on a single line
      using semicolons as follows:<br>
      <code>if <i>command</i>; <i>statements</i>; end</code>
    </div>

    <h3><a name="andAndOrCommands">and &amp; or Commands</a></h3>
    <div>
      In fish, <code>and</code> and <code>or</code> are commands,
      not keywords or operators.
      Both take a single argument which is a command
      to be conditionally executed based on the
      status of the previously executed command.
      If they do run the specified command,
      the <code>status</code> variable is set to
      the status of that command.
      Otherwise it is not changed.
    </div>
    <div>
      To conditionally execute a command only
      if the previous command was successful,
      <code><i>command1</i>; and <i>command2</i></code>.
      This is the same as
    </div>
    <pre>
<i>command1</i>
and <i>command2</i></pre>
    <div>
      This is not the same as
      <code><i>command1</i>; <i>command2</i></code>
      because that will run <code><i>command2</i></code>
      even if <code><i>command1</i></code>
      was not successful.
    </div>
    <div>
      To conditionally execute a command only
      if the previous command failed,
      <code><i>command1</i>; or <i>command2</i></code>.
    </div>
    <div>
      The <code>and</code> and <code>or</code> commands are often
      used in <code>if</code> and <code>while</code> commands.
    </div>

    <h3><a name="switchCommand">switch Command</a></h3>
    <div>
      The switch command conditionally executes other commands
      based on the value of a expression.
      Often the expression is the value of a single variable.
      It's syntax is:
    </div>
    <pre>
switch <i>expression</i> # ex. $color
  case <i>value1</i> <i>value2</i>
    <i>statements</i>
  case <i>value3</i>
    <i>statements</i>
  case '*' # like default in other languages
    <i>statements</i>
end</pre>
    </div>
      The expression should evaluate to a string.
      Note how a <code>case</code> can list more than one value.  Also note
      that a "break" statement is not needed at the end of each <code>case</code>
      because execution does not fall through as it does in many programming languages.
    <div>
      To treat one case value as the default, use
      <code>case default-value '*'</code>.
    </div>

    <h3><a name="LoopCommands">Loop Commands</a></h3>
    <div>
      Two kinds of loops are supported, <code>while</code> and <code>for</code>.
    </div>
    <div>
      The syntax for a <code>while</code> loop is:
    </div>
    <pre>
while <i>command</i>
  # commands go here
end</pre>
    <div>
      This uses the status of a command
      to determine whether to iterate again.
      It continues as long as the status is zero
      and stops when it is non-zero.
    </div>
    <div>
      For an endless loop, use the <code>true</code> command.
    </div>
    <div>
      To test multiple conditions, use the
      <code>and</code> and <code>or</code> commands.
    </div>
    <div>
      The syntax for a <code>for</code> loop is:
    </div>
    <pre>
for <i>var</i> in <i>list</i>
  # use $<i>var</i> here
end</pre>
    <div>
      To iterate over a list of numbers, use the <code>seq</code> command.
      For example, <code>for n in (seq 5); echo $n; end</code>
      outputs 1, 2, 3, 4, and 5 on separate lines.
      The <code>seq</code> command can be followed by 1, 2 or 3 numbers
      to specify the first, increment, and last values.
      If only one argument is supplied, it is the last,
      first defaults to 1, and incr defaults 1
      If only two arguments are supplied,
      they are the first and last values, and incr defaults to 1.
    </div>
    <div>
      A <code>for</code> command can be used to iterate over the relative file paths
      that match a pattern.  For example,
      <code>for path in b*.fish; echo $path; end</code>
    </div>
    <div>
      In both kinds of loops, use <code>break</code> to exit early and
      <code>continue</code> to skip the remainder of the current iteration.
    </div>

    <h3><a name="MultipleStatementsOnALine">Multiple Statements on a Line</a></h3>
    <div>
      A line can contain more than one statement if they are separated by semicolons.
      For example, <code>function foo; echo in foo; end</code>.
    </div>

    <h3><a name="CustomGreeting">Custom Greeting</a></h3>
    <div>
      By default, new fish shells display the greeting
      "Welcome to fish, the friendly interactive shell".
      To change this, enter something like
      <code>set -U fish_greeting 'You are a fish!'</code>.
      To suppress the greeting, erase the current setting with
      <code>set -e fish_greeting</code>.
    </div>

    <h3><a name="CustomPrompt">Custom Prompt</a></h3>
    <div>
      The default fish prompt displays the output of the
      <code>whoami</code> and <code>hostname</code> commands,
      followed by the abbreviated working directory
      (returned by the <code>prompt_pwd</code> command)
      and "<code>&gt;</code>".
      The abbreviated working directory output by
      <code>prompt_pwd</code> is so abbreviated that it isn't very useful.
      It is somewhat better if the characters per path part,
      which defaults to 1, is increased.
      To increase it to 3, enter
      <code>set fish_prompt_pwd_dir_length 3</code>.
    </div>
    <div>
      To customize the command prompt, create the file
      <code>~/.config/fish/functions/fish_prompt.fish</code>
      containing a function with the name <code>fish_prompt</code>
      that echoes the desired prompt.
      This can use the <code>set_color</code> command
      to control the colors of various parts.
      Any number of lines can be output, but typically
      there is only one and more than two is unusual.
    </div>
    <div>
      If the prompt doesn't fit in the current terminal width,
      it will instead just output "<code>&gt;</code>".
      The <code>fish_prompt</code> function can compare the length
      of what it wants to output with the <code>COLUMNS</code> variable
      and output something that fits.
    </div>
    <div>
      Here's an example of a custom prompt
      that takes the terminal width into account.
      Note that there is no way in fish to determine if the window width
      is less than 20 characters because when that is the case,
      the COLUMNS variable is set to 80.
      This is done because fish doesn't behave sensibly
      if the width is much less than 20.
    </div>
    <pre>
# This function is run every time Fish displays a new prompt.
function fish_prompt
  set vimModeLen 2 # appears at beginning of prompt (described later)
  set remaining (math "$COLUMNS - $vimModeLen")

  # Display present working directory.
  set_color --bold brblue # pwd color
  set pwdLen (string length $PWD)
  if test $pwdLen -le $remaining
    echo -n $PWD # -n suppresses newline at end
    set remaining (math "$remaining - $pwdLen")
  else
    echo -n (prompt_pwd) # abbreviated working directory
    set remaining 0
  end

  # Get the current Git branch.
  # This will be an empty string if not in a Git repo.
  set branch (git rev-parse --abbrev-ref HEAD ^/dev/null)

  # If in a Git repo ...
  if test -n "$branch"
    set branchLen (string length $branch)
    # If branch name won't fit on current line ...
    if test $branchLen -gt $remaining
      echo # newline
      echo -n '  ' # indents past Vim mode on previous line
      set remaining $COLUMNS # resets to full width
    else
      echo -n ' ' # space between PWD and branch name
    end

    # If branch name will fit on current line ...
    if test $branchLen -le $remaining
      # Display current Git branch.
      set_color --bold yellow # git branch color
      echo -n $branch
    end
    # If branch doesn't fit, it is not output.
  end

  # Display "fish" prompt on new line.
  set_color normal
  printf '\\n&#x1F420  ' # uses unicode for fish emoji;
end</pre>
    <div>
      It is also possible to define a "right prompt"
      by defining the function <code>fish_right_prompt</code>.
      This is right-aligned within terminals.
    </div>
    <div>
      If the <code>VISUAL</code> global variable is set to "vim",
      fish can display the Vim mode in the prompt
      using the function <code>fish_mode_prompt</code>.
      For example, this could display
      "N" for normal, "I" for insert, "R" for replace,
      and "V" for visual mode.
      This function outputs a new prompt every time the mode changes
      which is a bit distracting.
      To disable this feature,
      make this a function that doesn't output anything.
    </div>
    <div>
      Here's an example of a custom mode prompt.
      Newlines normally output by the <code>echo</code> command
      are stripped when this function runs.
    </div>
    <pre>
function fish_mode_prompt
  if test "$fish_key_bindings" = "fish_vi_key_bindings"
    switch $fish_bind_mode
      case default
        set_color red
        echo N
      case insert
        set_color green
        echo I
      case replace_one
        set_color green
        echo R
      case visual
        set_color magenta
        echo V
    end
    echo ' '
  end
end</pre>

    <h3><a name="ReadingFromStdin">Reading From stdin</a></h3>
    <div>
      The command <code>read <i>var</i></code>
      waits for the user to enter something, terminated by the enter key,
      and sets <code><i>var</i></code> to what was entered.
      Only a single line can be entered.
    </div>
    <div>
      The <code>read</code> command accepts many switches.
      It accepts the same switches as the <code>set</code> command
      for choosing the scope of the variable that is set.
      It also accepts the following switches:
    </div>
    <ul>
      <li>
        <code>--prompt-str <i>text</i></code> (<code>-P</code>)<br>
        This sets the prompt text which defaults to "read&gt; ".
        See the "favorite color" example below.
      </li>
      <li>
        <code>--prompt-cmd <i>command</i></code> (<code>-p</code>)<br>
        This sets the prompt text to the output of the specified command.
        It is useful for dynamic prompts.
        For example, to ask the user if they were born in the current month, use<br>
        <code>read --prompt-cmd "echo Were you born in (date '+%B')'? '" bornThisMonth</code>
      </li>
      <li>
        <code>--command <i>text</i></code> (<code>-c</code>)<br>
        This sets the initial text as if the user had entered it.
        The user can modify this.
        For example, to prompt for a meeting date
        and default to the current date,
        <code>read --command (date '+%m/%d/%G') meetingDate</code>
      </li>
      <li>
        <code>--silent</code> (<code>-i</code>)<br>
        This masks the input.  For example, this is appropriate for entering passwords.
      </li>
      <li>
        <code>--array</code> (<code>-a</code>)<br>
        This sets the variable to a list of the words entered
        instead of a single string value.
        For example, <code>read --array favColors</code> sets the variable
        <code>favColors</code> to the list of colors the user enters.
        If "red green blue" is entered, favColors will be set to that list
        and <code>count $colors</code> will output 3.
      </li>
      <li>and many more</li>
    </ul>
    <div>
      For example, to prompt the user for their favorite color,
      with the default being yellow, use
      <code>read --prompt-str 'Favorite color: ' --command yellow color</code>.
      This sets the variable <code>color</code> to what the user enters.
    </div>
    <div>
      The read command can set more than one variable.
      Each is set to the word at the corresponding position.
      The last variable gets all the remaining words.
      For example, if <code>read first second</code>
      is run and the user enters "foo bar baz",
      <code>first</code> is set to "foo" and
      <code>second</code> is set to "bar baz".
    </div>
    <div>
      To read multiple lines from the user
      until they press enter on an empty line:
    </div>
    <pre>
while read line
  if test -z $line; break; end
  echo you entered $line
end</pre>

    <h3><a name="DebuggingFunctions">Debugging Functions</a></h3>
    <div>
      A common way to debug functions is to add echo commands
      and comment out parts of the code.
      Often a better approach is to add breakpoints
      to stop execution at specific places.
      While stopped, variables can be examined and modified.
      Then execution can be continued.
    </div>
    <div>
      To add breakpoints in a function,
      add uses of the <code>breakpoint</code> command.
      After adding them, run the function.
      When a breakpoint is reached, the function will stop
      and control will be returned to the shell.
      Use the <code>echo</code> command to examine variables.
      and the <code>set</code> command to modify them.
      For example, <code>echo $count</code> and <code>set count 7</code>.
    </div>
    <div>
      To resume execution, enter <code>exit</code>.
      To stop the running function before it reaches its end,
      enter <code>kill %self</code>.
    </div>

    <h3><a name="OptionParsing">Option Parsing</a></h3>
    <div>
      Research the <code>getopt</code> command.
    </div>

    <h2><a name="Extras">Extras</a></h2>

    <h3><a name="AbsolutePath">Absolute Path</a></h3>
    <div>
      To get the absolute path of a relative path,
      use the <code>realpath</code> command.
      For example, when in the directory <code>/foo/bar/baz</code>,
     entering <code>realpath ../../qux</code>
     outputs <code>/foo/qux</code>.
    </div>

    <h3><a name="Processes">Processes</a></h3>
    <div>
      The <code>%</code> character followed by specific words
      expands to a process id.
      <code>%self</code> expands to the current process id.
      <code>%<i>jobNumber</i></code> expands to the
      process id of the specified job.
      <code>%<i>processName</i></code> expands to the
      process id of the specified process name.
      For example, to see the process ids of all fish processes,
      enter <code>echo %fish</code>.
      If only a process name prefix is specified, the ids of all
      processes with names beginning with that prefix are output.
    </div>

    <h3><a name="Jobs">Jobs</a></h3>
    <div>
      To run a command in background,
      add <code>&amp;</code> to end of the command.
      This does not work for custom functions.
      TODO: Why?
    </div>
    <div>
      To suspend a currently running command, press ctrl-z.
      This does not work for custom functions.
      TODO: Why?
    </div>
    <div>
      To continue running a suspended command in background
      enter <code>bg</code>.
    </div>
    <div>
      To get a list of background jobs and their job numbers,
      enter <code>jobs</code>.
    </div>
    <div>
      To bring a background job back to the foreground,
      enter <code>fg</code> for the job most recently placed in background.
      For a specific job, enter <code>fg %<i>jobNumber</i></code>
      or <code>fg <i>processNumber</i></code>.
    </div>
    <div>
      If you attempt to exit from a shell that has background jobs,
      it will warn about this and not exit.
      If you attempt to exit again,
      it will kill all the background jobs and exit.
    </div>

    <h3><a name="RandomNumbersAndOptions">Random Numbers and Options</a></h3>
    <div>
      The <code>random</code> command outputs
      an integer in the range [0, 32767].
      It takes up to three arguments and
      typically at least two are specified.
      Their meaning depends on the number given.
      If only one is specified, it is a seed.
      If two are specified,
      they are the start and end of the range.
      For example, for a dice roll use <code>random 1 6</code>.
      If three are specified,
      they are the start, step, and end of the range
      where only numbers that are increments of step from start
      will be generated.
      For example, to generate a random number between 0 and 100
      that is an increment of 5, use <code>random 0 5 100</code>.
    </div>
    <div>
      To select a random item from a list of options,
      use <code>random choice <i>option1</i> <i>option2</i> ...</code>.
      For example, to choose a random color from a list of options,
      <pre>
set colors red orange yellow green blue purple
set color (random choice $colors)</pre>
    </div>

    <hr>
LOOK FOR TODO IN THIS FILE!

TODO: Document how to use the "spin" function you installed.<br>
TODO: See .config/fish/functions/listrm.fish<br>
TODO: See .config/fish/functions/rmpath.fish<br>
TODO: For article<br>
- create example script in Fish, Bash, and Node
  that lists files containing given text in their name
  in tree form that colors file types differently
  (ex. red for .js, blue for .scss, ...)
  * maybe make colors configurable<br>
- get some ideas from the Wikipedia entry
  </body>
</html>
